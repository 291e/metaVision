"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-stdlib/controls/OrbitControls.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapControls: () => (/* binding */ MapControls),\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\nconst _ray = new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst _plane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180));\nconst moduloWrapAround = (offset, capacity) => (offset % capacity + capacity) % capacity;\nclass OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n  constructor(object, domElement) {\n    super();\n    __publicField(this, \"object\");\n    __publicField(this, \"domElement\");\n    // Set to false to disable this control\n    __publicField(this, \"enabled\", true);\n    // \"target\" sets the location of focus, where the object orbits around\n    __publicField(this, \"target\", new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    __publicField(this, \"minDistance\", 0);\n    __publicField(this, \"maxDistance\", Infinity);\n    // How far you can zoom in and out ( OrthographicCamera only )\n    __publicField(this, \"minZoom\", 0);\n    __publicField(this, \"maxZoom\", Infinity);\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    __publicField(this, \"minPolarAngle\", 0);\n    // radians\n    __publicField(this, \"maxPolarAngle\", Math.PI);\n    // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    __publicField(this, \"minAzimuthAngle\", -Infinity);\n    // radians\n    __publicField(this, \"maxAzimuthAngle\", Infinity);\n    // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"enableDamping\", false);\n    __publicField(this, \"dampingFactor\", 0.05);\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    __publicField(this, \"enableZoom\", true);\n    __publicField(this, \"zoomSpeed\", 1);\n    // Set to false to disable rotating\n    __publicField(this, \"enableRotate\", true);\n    __publicField(this, \"rotateSpeed\", 1);\n    // Set to false to disable panning\n    __publicField(this, \"enablePan\", true);\n    __publicField(this, \"panSpeed\", 1);\n    __publicField(this, \"screenSpacePanning\", true);\n    // if false, pan orthogonal to world-space direction camera.up\n    __publicField(this, \"keyPanSpeed\", 7);\n    // pixels moved per arrow key push\n    __publicField(this, \"zoomToCursor\", false);\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"autoRotate\", false);\n    __publicField(this, \"autoRotateSpeed\", 2);\n    // 30 seconds per orbit when fps is 60\n    __publicField(this, \"reverseOrbit\", false);\n    // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n    __publicField(this, \"reverseHorizontalOrbit\", false);\n    // true if you want to reverse the horizontal orbit direction\n    __publicField(this, \"reverseVerticalOrbit\", false);\n    // true if you want to reverse the vertical orbit direction\n    // The four arrow keys\n    __publicField(this, \"keys\", { LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \"ArrowDown\" });\n    // Mouse buttons\n    __publicField(this, \"mouseButtons\", {\n      LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE,\n      MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY,\n      RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN\n    });\n    // Touch fingers\n    __publicField(this, \"touches\", { ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN });\n    __publicField(this, \"target0\");\n    __publicField(this, \"position0\");\n    __publicField(this, \"zoom0\");\n    // the target DOM element for key events\n    __publicField(this, \"_domElementKeyEvents\", null);\n    __publicField(this, \"getPolarAngle\");\n    __publicField(this, \"getAzimuthalAngle\");\n    __publicField(this, \"setPolarAngle\");\n    __publicField(this, \"setAzimuthalAngle\");\n    __publicField(this, \"getDistance\");\n    __publicField(this, \"listenToKeyEvents\");\n    __publicField(this, \"stopListenToKeyEvents\");\n    __publicField(this, \"saveState\");\n    __publicField(this, \"reset\");\n    __publicField(this, \"update\");\n    __publicField(this, \"connect\");\n    __publicField(this, \"dispose\");\n    this.object = object;\n    this.domElement = domElement;\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n    this.getPolarAngle = () => spherical.phi;\n    this.getAzimuthalAngle = () => spherical.theta;\n    this.setPolarAngle = (value) => {\n      let phi = moduloWrapAround(value, 2 * Math.PI);\n      let currentPhi = spherical.phi;\n      if (currentPhi < 0)\n        currentPhi += 2 * Math.PI;\n      if (phi < 0)\n        phi += 2 * Math.PI;\n      let phiDist = Math.abs(phi - currentPhi);\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI;\n        } else {\n          currentPhi += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi;\n      scope.update();\n    };\n    this.setAzimuthalAngle = (value) => {\n      let theta = moduloWrapAround(value, 2 * Math.PI);\n      let currentTheta = spherical.theta;\n      if (currentTheta < 0)\n        currentTheta += 2 * Math.PI;\n      if (theta < 0)\n        theta += 2 * Math.PI;\n      let thetaDist = Math.abs(theta - currentTheta);\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI;\n        } else {\n          currentTheta += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta;\n      scope.update();\n    };\n    this.getDistance = () => scope.object.position.distanceTo(scope.target);\n    this.listenToKeyEvents = (domElement2) => {\n      domElement2.addEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = domElement2;\n    };\n    this.stopListenToKeyEvents = () => {\n      this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = null;\n    };\n    this.saveState = () => {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n    this.reset = () => {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(changeEvent);\n      scope.update();\n      state = STATE.NONE;\n    };\n    this.update = (() => {\n      const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const up = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n      const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors(object.up, up);\n      const quatInverse = quat.clone().invert();\n      const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n      const twoPI = 2 * Math.PI;\n      return function update() {\n        const position = scope.object.position;\n        quat.setFromUnitVectors(object.up, up);\n        quatInverse.copy(quat).invert();\n        offset.copy(position).sub(scope.target);\n        offset.applyQuaternion(quat);\n        spherical.setFromVector3(offset);\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        }\n        let min = scope.minAzimuthAngle;\n        let max = scope.maxAzimuthAngle;\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI)\n            min += twoPI;\n          else if (min > Math.PI)\n            min -= twoPI;\n          if (max < -Math.PI)\n            max += twoPI;\n          else if (max > Math.PI)\n            max -= twoPI;\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n          }\n        }\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n        spherical.makeSafe();\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius);\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale);\n        }\n        offset.setFromSpherical(spherical);\n        offset.applyQuaternion(quatInverse);\n        position.copy(scope.target).add(offset);\n        if (!scope.object.matrixAutoUpdate)\n          scope.object.updateMatrix();\n        scope.object.lookAt(scope.target);\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n          panOffset.set(0, 0, 0);\n        }\n        let zoomChanged = false;\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null;\n          if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            const prevRadius = offset.length();\n            newRadius = clampDistance(prevRadius * scale);\n            const radiusDelta = prevRadius - newRadius;\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n            scope.object.updateMatrixWorld();\n          } else if (scope.object.isOrthographicCamera) {\n            const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n            mouseBefore.unproject(scope.object);\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n            const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n            mouseAfter.unproject(scope.object);\n            scope.object.position.sub(mouseAfter).add(mouseBefore);\n            scope.object.updateMatrixWorld();\n            newRadius = offset.length();\n          } else {\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n            scope.zoomToCursor = false;\n          }\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n            } else {\n              _ray.origin.copy(scope.object.position);\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target);\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                _ray.intersectPlane(_plane, scope.target);\n              }\n            }\n          }\n        } else if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1;\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n          }\n        }\n        scale = 1;\n        performCursorZoom = false;\n        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n          scope.dispatchEvent(changeEvent);\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n        return false;\n      };\n    })();\n    this.connect = (domElement2) => {\n      scope.domElement = domElement2;\n      scope.domElement.style.touchAction = \"none\";\n      scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n      scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n      scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n      scope.domElement.addEventListener(\"wheel\", onMouseWheel);\n    };\n    this.dispose = () => {\n      var _a, _b, _c, _d, _e, _f;\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = \"auto\";\n      }\n      (_a = scope.domElement) == null ? void 0 : _a.removeEventListener(\"contextmenu\", onContextMenu);\n      (_b = scope.domElement) == null ? void 0 : _b.removeEventListener(\"pointerdown\", onPointerDown);\n      (_c = scope.domElement) == null ? void 0 : _c.removeEventListener(\"pointercancel\", onPointerUp);\n      (_d = scope.domElement) == null ? void 0 : _d.removeEventListener(\"wheel\", onMouseWheel);\n      (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n      (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      }\n    };\n    const scope = this;\n    const changeEvent = { type: \"change\" };\n    const startEvent = { type: \"start\" };\n    const endEvent = { type: \"end\" };\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6\n    };\n    let state = STATE.NONE;\n    const EPS = 1e-6;\n    const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n    const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n    let scale = 1;\n    const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    let performCursorZoom = false;\n    const pointers = [];\n    const pointerPositions = {};\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n    function rotateLeft(angle) {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle;\n      } else {\n        sphericalDelta.theta -= angle;\n      }\n    }\n    function rotateUp(angle) {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle;\n      } else {\n        sphericalDelta.phi -= angle;\n      }\n    }\n    const panLeft = (() => {\n      const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function panLeft2(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    })();\n    const panUp = (() => {\n      const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function panUp2(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    })();\n    const pan = (() => {\n      const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function pan2(deltaX, deltaY) {\n        const element = scope.domElement;\n        if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          const position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          let targetDistance = offset.length();\n          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\n          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n        } else if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n          panLeft(\n            deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix\n          );\n          panUp(\n            deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix\n          );\n        } else {\n          console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n          scope.enablePan = false;\n        }\n      };\n    })();\n    function dollyOut(dollyScale) {\n      if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n        scale /= dollyScale;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n    function dollyIn(dollyScale) {\n      if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n        scale *= dollyScale;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n    function updateMouseParameters(event) {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return;\n      }\n      performCursorZoom = true;\n      const rect = scope.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const w = rect.width;\n      const h = rect.height;\n      mouse.x = x / w * 2 - 1;\n      mouse.y = -(y / h) * 2 + 1;\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n    }\n    function clampDistance(dist) {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n    }\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownDolly(event) {\n      updateMouseParameters(event);\n      dollyStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseMoveRotate(event) {\n      rotateEnd.set(event.clientX, event.clientY);\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n      scope.update();\n    }\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n      dollyStart.copy(dollyEnd);\n      scope.update();\n    }\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n      scope.update();\n    }\n    function handleMouseWheel(event) {\n      updateMouseParameters(event);\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n      scope.update();\n    }\n    function handleKeyDown(event) {\n      let needsUpdate = false;\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n      if (needsUpdate) {\n        event.preventDefault();\n        scope.update();\n      }\n    }\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        rotateStart.set(x, y);\n      }\n    }\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        panStart.set(x, y);\n      }\n    }\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX;\n      const dy = pointers[0].pageY - pointers[1].pageY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enablePan)\n        handleTouchStartPan();\n    }\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enableRotate)\n        handleTouchStartRotate();\n    }\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        rotateEnd.set(x, y);\n      }\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n    }\n    function handleTouchMovePan(event) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        panEnd.set(x, y);\n      }\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n    function handleTouchMoveDolly(event) {\n      const position = getSecondPointerPosition(event);\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyEnd.set(0, distance);\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n      dollyOut(dollyDelta.y);\n      dollyStart.copy(dollyEnd);\n    }\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enablePan)\n        handleTouchMovePan(event);\n    }\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enableRotate)\n        handleTouchMoveRotate(event);\n    }\n    function onPointerDown(event) {\n      var _a, _b;\n      if (scope.enabled === false)\n        return;\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n      }\n      addPointer(event);\n      if (event.pointerType === \"touch\") {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n    function onPointerMove(event) {\n      if (scope.enabled === false)\n        return;\n      if (event.pointerType === \"touch\") {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n    function onPointerUp(event) {\n      var _a, _b, _c;\n      removePointer(event);\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.releasePointerCapture(event.pointerId);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n        (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      }\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n    function onMouseDown(event) {\n      let mouseAction;\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n        default:\n          mouseAction = -1;\n      }\n      switch (mouseAction) {\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseDownDolly(event);\n          state = STATE.DOLLY;\n          break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          }\n          break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onMouseMove(event) {\n      if (scope.enabled === false)\n        return;\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleMouseMoveRotate(event);\n          break;\n        case STATE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseMoveDolly(event);\n          break;\n        case STATE.PAN:\n          if (scope.enablePan === false)\n            return;\n          handleMouseMovePan(event);\n          break;\n      }\n    }\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) {\n        return;\n      }\n      event.preventDefault();\n      scope.dispatchEvent(startEvent);\n      handleMouseWheel(event);\n      scope.dispatchEvent(endEvent);\n    }\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false)\n        return;\n      handleKeyDown(event);\n    }\n    function onTouchStart(event) {\n      trackPointer(event);\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n              if (scope.enableRotate === false)\n                return;\n              handleTouchStartRotate();\n              state = STATE.TOUCH_ROTATE;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n              if (scope.enablePan === false)\n                return;\n              handleTouchStartPan();\n              state = STATE.TOUCH_PAN;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        case 2:\n          switch (scope.touches.TWO) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false)\n                return;\n              handleTouchStartDollyPan();\n              state = STATE.TOUCH_DOLLY_PAN;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false)\n                return;\n              handleTouchStartDollyRotate();\n              state = STATE.TOUCH_DOLLY_ROTATE;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onTouchMove(event) {\n      trackPointer(event);\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleTouchMoveRotate(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false)\n            return;\n          handleTouchMovePan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false)\n            return;\n          handleTouchMoveDollyPan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false)\n            return;\n          handleTouchMoveDollyRotate(event);\n          scope.update();\n          break;\n        default:\n          state = STATE.NONE;\n      }\n    }\n    function onContextMenu(event) {\n      if (scope.enabled === false)\n        return;\n      event.preventDefault();\n    }\n    function addPointer(event) {\n      pointers.push(event);\n    }\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n    function trackPointer(event) {\n      let position = pointerPositions[event.pointerId];\n      if (position === void 0) {\n        position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n      position.set(event.pageX, event.pageY);\n    }\n    function getSecondPointerPosition(event) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n      return pointerPositions[pointer.pointerId];\n    }\n    if (domElement !== void 0)\n      this.connect(domElement);\n    this.update();\n  }\n}\nclass MapControls extends OrbitControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n    this.screenSpacePanning = false;\n    this.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;\n    this.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;\n    this.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;\n    this.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;\n  }\n}\n\n//# sourceMappingURL=OrbitControls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ2tKO0FBQ2xKLGlCQUFpQixzQ0FBRztBQUNwQixtQkFBbUIsd0NBQUs7QUFDeEI7QUFDQTtBQUNBLDRCQUE0QixrREFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQ0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRFQUE0RTtBQUM5RztBQUNBO0FBQ0EsWUFBWSx3Q0FBSztBQUNqQixjQUFjLHdDQUFLO0FBQ25CLGFBQWEsd0NBQUs7QUFDbEIsS0FBSztBQUNMO0FBQ0EscUNBQXFDLEtBQUssd0NBQUssY0FBYyx3Q0FBSyxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQU87QUFDaEMscUJBQXFCLDBDQUFPO0FBQzVCLHVCQUF1Qiw2Q0FBVTtBQUNqQztBQUNBLCtCQUErQiwwQ0FBTztBQUN0QyxpQ0FBaUMsNkNBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9EQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG9DQUFvQywwQ0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQ0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDLHFEQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBUztBQUNuQywrQkFBK0IsNENBQVM7QUFDeEM7QUFDQSwwQkFBMEIsMENBQU87QUFDakMsNEJBQTRCLDBDQUFPO0FBQ25DLDBCQUEwQiwwQ0FBTztBQUNqQyw0QkFBNEIsMENBQU87QUFDbkMseUJBQXlCLDBDQUFPO0FBQ2hDLHVCQUF1QiwwQ0FBTztBQUM5Qix5QkFBeUIsMENBQU87QUFDaEMsMkJBQTJCLDBDQUFPO0FBQ2xDLHlCQUF5QiwwQ0FBTztBQUNoQywyQkFBMkIsMENBQU87QUFDbEMsK0JBQStCLDBDQUFPO0FBQ3RDLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsMENBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QiwwQ0FBTztBQUNoQztBQUNBO0FBQ0EsK0NBQStDLG9EQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QyxxREFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxvREFBaUIsZ0VBQWdFLHFEQUFrQjtBQUNySTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9EQUFpQixnRUFBZ0UscURBQWtCO0FBQ3JJO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3Q0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3Q0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQUs7QUFDbEMsOEJBQThCLHdDQUFLO0FBQ25DLHVCQUF1Qix3Q0FBSztBQUM1Qix1QkFBdUIsd0NBQUs7QUFDNUI7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXRhMzYwLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9jb250cm9scy9PcmJpdENvbnRyb2xzLmpzPzFiNWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuaW1wb3J0IHsgUmF5LCBQbGFuZSwgRXZlbnREaXNwYXRjaGVyLCBWZWN0b3IzLCBNT1VTRSwgVE9VQ0gsIFF1YXRlcm5pb24sIFBlcnNwZWN0aXZlQ2FtZXJhLCBPcnRob2dyYXBoaWNDYW1lcmEsIFNwaGVyaWNhbCwgVmVjdG9yMiB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgX3JheSA9IG5ldyBSYXkoKTtcbmNvbnN0IF9wbGFuZSA9IG5ldyBQbGFuZSgpO1xuY29uc3QgVElMVF9MSU1JVCA9IE1hdGguY29zKDcwICogKE1hdGguUEkgLyAxODApKTtcbmNvbnN0IG1vZHVsb1dyYXBBcm91bmQgPSAob2Zmc2V0LCBjYXBhY2l0eSkgPT4gKG9mZnNldCAlIGNhcGFjaXR5ICsgY2FwYWNpdHkpICUgY2FwYWNpdHk7XG5jbGFzcyBPcmJpdENvbnRyb2xzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib2JqZWN0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb21FbGVtZW50XCIpO1xuICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YXJnZXRcIiwgbmV3IFZlY3RvcjMoKSk7XG4gICAgLy8gSG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXQgKCBQZXJzcGVjdGl2ZUNhbWVyYSBvbmx5IClcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluRGlzdGFuY2VcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heERpc3RhbmNlXCIsIEluZmluaXR5KTtcbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gem9vbSBpbiBhbmQgb3V0ICggT3J0aG9ncmFwaGljQ2FtZXJhIG9ubHkgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5ab29tXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhab29tXCIsIEluZmluaXR5KTtcbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cbiAgICAvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluUG9sYXJBbmdsZVwiLCAwKTtcbiAgICAvLyByYWRpYW5zXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heFBvbGFyQW5nbGVcIiwgTWF0aC5QSSk7XG4gICAgLy8gcmFkaWFuc1xuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gICAgLy8gSWYgc2V0LCB0aGUgaW50ZXJ2YWwgWyBtaW4sIG1heCBdIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgWyAtIDIgUEksIDIgUEkgXSwgd2l0aCAoIG1heCAtIG1pbiA8IDIgUEkgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5BemltdXRoQW5nbGVcIiwgLUluZmluaXR5KTtcbiAgICAvLyByYWRpYW5zXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heEF6aW11dGhBbmdsZVwiLCBJbmZpbml0eSk7XG4gICAgLy8gcmFkaWFuc1xuICAgIC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuICAgIC8vIElmIGRhbXBpbmcgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuYWJsZURhbXBpbmdcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYW1waW5nRmFjdG9yXCIsIDAuMDUpO1xuICAgIC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVab29tXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ6b29tU3BlZWRcIiwgMSk7XG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcm90YXRpbmdcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW5hYmxlUm90YXRlXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyb3RhdGVTcGVlZFwiLCAxKTtcbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwYW5uaW5nXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuYWJsZVBhblwiLCB0cnVlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFuU3BlZWRcIiwgMSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNjcmVlblNwYWNlUGFubmluZ1wiLCB0cnVlKTtcbiAgICAvLyBpZiBmYWxzZSwgcGFuIG9ydGhvZ29uYWwgdG8gd29ybGQtc3BhY2UgZGlyZWN0aW9uIGNhbWVyYS51cFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJrZXlQYW5TcGVlZFwiLCA3KTtcbiAgICAvLyBwaXhlbHMgbW92ZWQgcGVyIGFycm93IGtleSBwdXNoXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInpvb21Ub0N1cnNvclwiLCBmYWxzZSk7XG4gICAgLy8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcbiAgICAvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXV0b1JvdGF0ZVwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dG9Sb3RhdGVTcGVlZFwiLCAyKTtcbiAgICAvLyAzMCBzZWNvbmRzIHBlciBvcmJpdCB3aGVuIGZwcyBpcyA2MFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlT3JiaXRcIiwgZmFsc2UpO1xuICAgIC8vIHRydWUgaWYgeW91IHdhbnQgdG8gcmV2ZXJzZSB0aGUgb3JiaXQgdG8gbW91c2UgZHJhZyBmcm9tIGxlZnQgdG8gcmlnaHQgPSBvcmJpdHMgbGVmdFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlSG9yaXpvbnRhbE9yYml0XCIsIGZhbHNlKTtcbiAgICAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIGhvcml6b250YWwgb3JiaXQgZGlyZWN0aW9uXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJldmVyc2VWZXJ0aWNhbE9yYml0XCIsIGZhbHNlKTtcbiAgICAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIHZlcnRpY2FsIG9yYml0IGRpcmVjdGlvblxuICAgIC8vIFRoZSBmb3VyIGFycm93IGtleXNcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2V5c1wiLCB7IExFRlQ6IFwiQXJyb3dMZWZ0XCIsIFVQOiBcIkFycm93VXBcIiwgUklHSFQ6IFwiQXJyb3dSaWdodFwiLCBCT1RUT006IFwiQXJyb3dEb3duXCIgfSk7XG4gICAgLy8gTW91c2UgYnV0dG9uc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3VzZUJ1dHRvbnNcIiwge1xuICAgICAgTEVGVDogTU9VU0UuUk9UQVRFLFxuICAgICAgTUlERExFOiBNT1VTRS5ET0xMWSxcbiAgICAgIFJJR0hUOiBNT1VTRS5QQU5cbiAgICB9KTtcbiAgICAvLyBUb3VjaCBmaW5nZXJzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRvdWNoZXNcIiwgeyBPTkU6IFRPVUNILlJPVEFURSwgVFdPOiBUT1VDSC5ET0xMWV9QQU4gfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhcmdldDBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvc2l0aW9uMFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiem9vbTBcIik7XG4gICAgLy8gdGhlIHRhcmdldCBET00gZWxlbWVudCBmb3Iga2V5IGV2ZW50c1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZG9tRWxlbWVudEtleUV2ZW50c1wiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0UG9sYXJBbmdsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0QXppbXV0aGFsQW5nbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldFBvbGFyQW5nbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldEF6aW11dGhhbEFuZ2xlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXREaXN0YW5jZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGlzdGVuVG9LZXlFdmVudHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3BMaXN0ZW5Ub0tleUV2ZW50c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2F2ZVN0YXRlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNldFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXBkYXRlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25uZWN0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkaXNwb3NlXCIpO1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcbiAgICB0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG4gICAgdGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb207XG4gICAgdGhpcy5nZXRQb2xhckFuZ2xlID0gKCkgPT4gc3BoZXJpY2FsLnBoaTtcbiAgICB0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gKCkgPT4gc3BoZXJpY2FsLnRoZXRhO1xuICAgIHRoaXMuc2V0UG9sYXJBbmdsZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgbGV0IHBoaSA9IG1vZHVsb1dyYXBBcm91bmQodmFsdWUsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGxldCBjdXJyZW50UGhpID0gc3BoZXJpY2FsLnBoaTtcbiAgICAgIGlmIChjdXJyZW50UGhpIDwgMClcbiAgICAgICAgY3VycmVudFBoaSArPSAyICogTWF0aC5QSTtcbiAgICAgIGlmIChwaGkgPCAwKVxuICAgICAgICBwaGkgKz0gMiAqIE1hdGguUEk7XG4gICAgICBsZXQgcGhpRGlzdCA9IE1hdGguYWJzKHBoaSAtIGN1cnJlbnRQaGkpO1xuICAgICAgaWYgKDIgKiBNYXRoLlBJIC0gcGhpRGlzdCA8IHBoaURpc3QpIHtcbiAgICAgICAgaWYgKHBoaSA8IGN1cnJlbnRQaGkpIHtcbiAgICAgICAgICBwaGkgKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBoaSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3BoZXJpY2FsRGVsdGEucGhpID0gcGhpIC0gY3VycmVudFBoaTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5zZXRBemltdXRoYWxBbmdsZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgbGV0IHRoZXRhID0gbW9kdWxvV3JhcEFyb3VuZCh2YWx1ZSwgMiAqIE1hdGguUEkpO1xuICAgICAgbGV0IGN1cnJlbnRUaGV0YSA9IHNwaGVyaWNhbC50aGV0YTtcbiAgICAgIGlmIChjdXJyZW50VGhldGEgPCAwKVxuICAgICAgICBjdXJyZW50VGhldGEgKz0gMiAqIE1hdGguUEk7XG4gICAgICBpZiAodGhldGEgPCAwKVxuICAgICAgICB0aGV0YSArPSAyICogTWF0aC5QSTtcbiAgICAgIGxldCB0aGV0YURpc3QgPSBNYXRoLmFicyh0aGV0YSAtIGN1cnJlbnRUaGV0YSk7XG4gICAgICBpZiAoMiAqIE1hdGguUEkgLSB0aGV0YURpc3QgPCB0aGV0YURpc3QpIHtcbiAgICAgICAgaWYgKHRoZXRhIDwgY3VycmVudFRoZXRhKSB7XG4gICAgICAgICAgdGhldGEgKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFRoZXRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSA9IHRoZXRhIC0gY3VycmVudFRoZXRhO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldERpc3RhbmNlID0gKCkgPT4gc2NvcGUub2JqZWN0LnBvc2l0aW9uLmRpc3RhbmNlVG8oc2NvcGUudGFyZ2V0KTtcbiAgICB0aGlzLmxpc3RlblRvS2V5RXZlbnRzID0gKGRvbUVsZW1lbnQyKSA9PiB7XG4gICAgICBkb21FbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgdGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cyA9IGRvbUVsZW1lbnQyO1xuICAgIH07XG4gICAgdGhpcy5zdG9wTGlzdGVuVG9LZXlFdmVudHMgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICB0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcbiAgICB9O1xuICAgIHRoaXMuc2F2ZVN0YXRlID0gKCkgPT4ge1xuICAgICAgc2NvcGUudGFyZ2V0MC5jb3B5KHNjb3BlLnRhcmdldCk7XG4gICAgICBzY29wZS5wb3NpdGlvbjAuY29weShzY29wZS5vYmplY3QucG9zaXRpb24pO1xuICAgICAgc2NvcGUuem9vbTAgPSBzY29wZS5vYmplY3Quem9vbTtcbiAgICB9O1xuICAgIHRoaXMucmVzZXQgPSAoKSA9PiB7XG4gICAgICBzY29wZS50YXJnZXQuY29weShzY29wZS50YXJnZXQwKTtcbiAgICAgIHNjb3BlLm9iamVjdC5wb3NpdGlvbi5jb3B5KHNjb3BlLnBvc2l0aW9uMCk7XG4gICAgICBzY29wZS5vYmplY3Quem9vbSA9IHNjb3BlLnpvb20wO1xuICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY29uc3QgdXAgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcbiAgICAgIGNvbnN0IHF1YXQgPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyhvYmplY3QudXAsIHVwKTtcbiAgICAgIGNvbnN0IHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVydCgpO1xuICAgICAgY29uc3QgbGFzdFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNvbnN0IGxhc3RRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgIGNvbnN0IHR3b1BJID0gMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvbjtcbiAgICAgICAgcXVhdC5zZXRGcm9tVW5pdFZlY3RvcnMob2JqZWN0LnVwLCB1cCk7XG4gICAgICAgIHF1YXRJbnZlcnNlLmNvcHkocXVhdCkuaW52ZXJ0KCk7XG4gICAgICAgIG9mZnNldC5jb3B5KHBvc2l0aW9uKS5zdWIoc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbihxdWF0KTtcbiAgICAgICAgc3BoZXJpY2FsLnNldEZyb21WZWN0b3IzKG9mZnNldCk7XG4gICAgICAgIGlmIChzY29wZS5hdXRvUm90YXRlICYmIHN0YXRlID09PSBTVEFURS5OT05FKSB7XG4gICAgICAgICAgcm90YXRlTGVmdChnZXRBdXRvUm90YXRpb25BbmdsZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUuZW5hYmxlRGFtcGluZykge1xuICAgICAgICAgIHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YSAqIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG4gICAgICAgICAgc3BoZXJpY2FsLnBoaSArPSBzcGhlcmljYWxEZWx0YS5waGkgKiBzY29wZS5kYW1waW5nRmFjdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YTtcbiAgICAgICAgICBzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWluID0gc2NvcGUubWluQXppbXV0aEFuZ2xlO1xuICAgICAgICBsZXQgbWF4ID0gc2NvcGUubWF4QXppbXV0aEFuZ2xlO1xuICAgICAgICBpZiAoaXNGaW5pdGUobWluKSAmJiBpc0Zpbml0ZShtYXgpKSB7XG4gICAgICAgICAgaWYgKG1pbiA8IC1NYXRoLlBJKVxuICAgICAgICAgICAgbWluICs9IHR3b1BJO1xuICAgICAgICAgIGVsc2UgaWYgKG1pbiA+IE1hdGguUEkpXG4gICAgICAgICAgICBtaW4gLT0gdHdvUEk7XG4gICAgICAgICAgaWYgKG1heCA8IC1NYXRoLlBJKVxuICAgICAgICAgICAgbWF4ICs9IHR3b1BJO1xuICAgICAgICAgIGVsc2UgaWYgKG1heCA+IE1hdGguUEkpXG4gICAgICAgICAgICBtYXggLT0gdHdvUEk7XG4gICAgICAgICAgaWYgKG1pbiA8PSBtYXgpIHtcbiAgICAgICAgICAgIHNwaGVyaWNhbC50aGV0YSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBzcGhlcmljYWwudGhldGEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BoZXJpY2FsLnRoZXRhID0gc3BoZXJpY2FsLnRoZXRhID4gKG1pbiArIG1heCkgLyAyID8gTWF0aC5tYXgobWluLCBzcGhlcmljYWwudGhldGEpIDogTWF0aC5taW4obWF4LCBzcGhlcmljYWwudGhldGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzcGhlcmljYWwucGhpID0gTWF0aC5tYXgoc2NvcGUubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oc2NvcGUubWF4UG9sYXJBbmdsZSwgc3BoZXJpY2FsLnBoaSkpO1xuICAgICAgICBzcGhlcmljYWwubWFrZVNhZmUoKTtcbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBzY29wZS50YXJnZXQuYWRkU2NhbGVkVmVjdG9yKHBhbk9mZnNldCwgc2NvcGUuZGFtcGluZ0ZhY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NvcGUudGFyZ2V0LmFkZChwYW5PZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZS56b29tVG9DdXJzb3IgJiYgcGVyZm9ybUN1cnNvclpvb20gfHwgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgICAgc3BoZXJpY2FsLnJhZGl1cyA9IGNsYW1wRGlzdGFuY2Uoc3BoZXJpY2FsLnJhZGl1cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BoZXJpY2FsLnJhZGl1cyA9IGNsYW1wRGlzdGFuY2Uoc3BoZXJpY2FsLnJhZGl1cyAqIHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQuc2V0RnJvbVNwaGVyaWNhbChzcGhlcmljYWwpO1xuICAgICAgICBvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKHF1YXRJbnZlcnNlKTtcbiAgICAgICAgcG9zaXRpb24uY29weShzY29wZS50YXJnZXQpLmFkZChvZmZzZXQpO1xuICAgICAgICBpZiAoIXNjb3BlLm9iamVjdC5tYXRyaXhBdXRvVXBkYXRlKVxuICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgc2NvcGUub2JqZWN0Lmxvb2tBdChzY29wZS50YXJnZXQpO1xuICAgICAgICBpZiAoc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhICo9IDEgLSBzY29wZS5kYW1waW5nRmFjdG9yO1xuICAgICAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSAqPSAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvcjtcbiAgICAgICAgICBwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwaGVyaWNhbERlbHRhLnNldCgwLCAwLCAwKTtcbiAgICAgICAgICBwYW5PZmZzZXQuc2V0KDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB6b29tQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2NvcGUuem9vbVRvQ3Vyc29yICYmIHBlcmZvcm1DdXJzb3Jab29tKSB7XG4gICAgICAgICAgbGV0IG5ld1JhZGl1cyA9IG51bGw7XG4gICAgICAgICAgaWYgKHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2UmFkaXVzID0gb2Zmc2V0Lmxlbmd0aCgpO1xuICAgICAgICAgICAgbmV3UmFkaXVzID0gY2xhbXBEaXN0YW5jZShwcmV2UmFkaXVzICogc2NhbGUpO1xuICAgICAgICAgICAgY29uc3QgcmFkaXVzRGVsdGEgPSBwcmV2UmFkaXVzIC0gbmV3UmFkaXVzO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnBvc2l0aW9uLmFkZFNjYWxlZFZlY3Rvcihkb2xseURpcmVjdGlvbiwgcmFkaXVzRGVsdGEpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlQmVmb3JlID0gbmV3IFZlY3RvcjMobW91c2UueCwgbW91c2UueSwgMCk7XG4gICAgICAgICAgICBtb3VzZUJlZm9yZS51bnByb2plY3Qoc2NvcGUub2JqZWN0KTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoc2NvcGUubWluWm9vbSwgTWF0aC5taW4oc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gLyBzY2FsZSkpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIHpvb21DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlQWZ0ZXIgPSBuZXcgVmVjdG9yMyhtb3VzZS54LCBtb3VzZS55LCAwKTtcbiAgICAgICAgICAgIG1vdXNlQWZ0ZXIudW5wcm9qZWN0KHNjb3BlLm9iamVjdCk7XG4gICAgICAgICAgICBzY29wZS5vYmplY3QucG9zaXRpb24uc3ViKG1vdXNlQWZ0ZXIpLmFkZChtb3VzZUJlZm9yZSk7XG4gICAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgICAgIG5ld1JhZGl1cyA9IG9mZnNldC5sZW5ndGgoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gem9vbSB0byBjdXJzb3IgZGlzYWJsZWQuXCIpO1xuICAgICAgICAgICAgc2NvcGUuem9vbVRvQ3Vyc29yID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdSYWRpdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5zY3JlZW5TcGFjZVBhbm5pbmcpIHtcbiAgICAgICAgICAgICAgc2NvcGUudGFyZ2V0LnNldCgwLCAwLCAtMSkudHJhbnNmb3JtRGlyZWN0aW9uKHNjb3BlLm9iamVjdC5tYXRyaXgpLm11bHRpcGx5U2NhbGFyKG5ld1JhZGl1cykuYWRkKHNjb3BlLm9iamVjdC5wb3NpdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfcmF5Lm9yaWdpbi5jb3B5KHNjb3BlLm9iamVjdC5wb3NpdGlvbik7XG4gICAgICAgICAgICAgIF9yYXkuZGlyZWN0aW9uLnNldCgwLCAwLCAtMSkudHJhbnNmb3JtRGlyZWN0aW9uKHNjb3BlLm9iamVjdC5tYXRyaXgpO1xuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc2NvcGUub2JqZWN0LnVwLmRvdChfcmF5LmRpcmVjdGlvbikpIDwgVElMVF9MSU1JVCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5sb29rQXQoc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoc2NvcGUub2JqZWN0LnVwLCBzY29wZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIF9yYXkuaW50ZXJzZWN0UGxhbmUoX3BsYW5lLCBzY29wZS50YXJnZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHNjYWxlICE9PSAxO1xuICAgICAgICAgIGlmICh6b29tQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heChzY29wZS5taW5ab29tLCBNYXRoLm1pbihzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAvIHNjYWxlKSk7XG4gICAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2FsZSA9IDE7XG4gICAgICAgIHBlcmZvcm1DdXJzb3Jab29tID0gZmFsc2U7XG4gICAgICAgIGlmICh6b29tQ2hhbmdlZCB8fCBsYXN0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoc2NvcGUub2JqZWN0LnBvc2l0aW9uKSA+IEVQUyB8fCA4ICogKDEgLSBsYXN0UXVhdGVybmlvbi5kb3Qoc2NvcGUub2JqZWN0LnF1YXRlcm5pb24pKSA+IEVQUykge1xuICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuICAgICAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KHNjb3BlLm9iamVjdC5wb3NpdGlvbik7XG4gICAgICAgICAgbGFzdFF1YXRlcm5pb24uY29weShzY29wZS5vYmplY3QucXVhdGVybmlvbik7XG4gICAgICAgICAgem9vbUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5jb25uZWN0ID0gKGRvbUVsZW1lbnQyKSA9PiB7XG4gICAgICBzY29wZS5kb21FbGVtZW50ID0gZG9tRWxlbWVudDI7XG4gICAgICBzY29wZS5kb21FbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIG9uUG9pbnRlckRvd24pO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJVcCk7XG4gICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBvbk1vdXNlV2hlZWwpO1xuICAgIH07XG4gICAgdGhpcy5kaXNwb3NlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICBpZiAoc2NvcGUuZG9tRWxlbWVudCkge1xuICAgICAgICBzY29wZS5kb21FbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gXCJhdXRvXCI7XG4gICAgICB9XG4gICAgICAoX2EgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgKF9iID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBvblBvaW50ZXJEb3duKTtcbiAgICAgIChfYyA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJVcCk7XG4gICAgICAoX2QgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIG9uTW91c2VXaGVlbCk7XG4gICAgICAoX2UgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Uub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSk7XG4gICAgICAoX2YgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Yub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwKTtcbiAgICAgIGlmIChzY29wZS5fZG9tRWxlbWVudEtleUV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICBzY29wZS5fZG9tRWxlbWVudEtleUV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZUV2ZW50ID0geyB0eXBlOiBcImNoYW5nZVwiIH07XG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHsgdHlwZTogXCJzdGFydFwiIH07XG4gICAgY29uc3QgZW5kRXZlbnQgPSB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgICBjb25zdCBTVEFURSA9IHtcbiAgICAgIE5PTkU6IC0xLFxuICAgICAgUk9UQVRFOiAwLFxuICAgICAgRE9MTFk6IDEsXG4gICAgICBQQU46IDIsXG4gICAgICBUT1VDSF9ST1RBVEU6IDMsXG4gICAgICBUT1VDSF9QQU46IDQsXG4gICAgICBUT1VDSF9ET0xMWV9QQU46IDUsXG4gICAgICBUT1VDSF9ET0xMWV9ST1RBVEU6IDZcbiAgICB9O1xuICAgIGxldCBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgY29uc3QgRVBTID0gMWUtNjtcbiAgICBjb25zdCBzcGhlcmljYWwgPSBuZXcgU3BoZXJpY2FsKCk7XG4gICAgY29uc3Qgc3BoZXJpY2FsRGVsdGEgPSBuZXcgU3BoZXJpY2FsKCk7XG4gICAgbGV0IHNjYWxlID0gMTtcbiAgICBjb25zdCBwYW5PZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHJvdGF0ZVN0YXJ0ID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCByb3RhdGVFbmQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHJvdGF0ZURlbHRhID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBwYW5TdGFydCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcGFuRW5kID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBwYW5EZWx0YSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgZG9sbHlTdGFydCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgZG9sbHlFbmQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IGRvbGx5RGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IGRvbGx5RGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCBtb3VzZSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgbGV0IHBlcmZvcm1DdXJzb3Jab29tID0gZmFsc2U7XG4gICAgY29uc3QgcG9pbnRlcnMgPSBbXTtcbiAgICBjb25zdCBwb2ludGVyUG9zaXRpb25zID0ge307XG4gICAgZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XG4gICAgICByZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMC45NSwgc2NvcGUuem9vbVNwZWVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRlTGVmdChhbmdsZSkge1xuICAgICAgaWYgKHNjb3BlLnJldmVyc2VPcmJpdCB8fCBzY29wZS5yZXZlcnNlSG9yaXpvbnRhbE9yYml0KSB7XG4gICAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhICs9IGFuZ2xlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BoZXJpY2FsRGVsdGEudGhldGEgLT0gYW5nbGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0ZVVwKGFuZ2xlKSB7XG4gICAgICBpZiAoc2NvcGUucmV2ZXJzZU9yYml0IHx8IHNjb3BlLnJldmVyc2VWZXJ0aWNhbE9yYml0KSB7XG4gICAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSArPSBhbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSAtPSBhbmdsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFuTGVmdCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwYW5MZWZ0MihkaXN0YW5jZSwgb2JqZWN0TWF0cml4KSB7XG4gICAgICAgIHYuc2V0RnJvbU1hdHJpeENvbHVtbihvYmplY3RNYXRyaXgsIDApO1xuICAgICAgICB2Lm11bHRpcGx5U2NhbGFyKC1kaXN0YW5jZSk7XG4gICAgICAgIHBhbk9mZnNldC5hZGQodik7XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgY29uc3QgcGFuVXAgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcGFuVXAyKGRpc3RhbmNlLCBvYmplY3RNYXRyaXgpIHtcbiAgICAgICAgaWYgKHNjb3BlLnNjcmVlblNwYWNlUGFubmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHYuc2V0RnJvbU1hdHJpeENvbHVtbihvYmplY3RNYXRyaXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYuc2V0RnJvbU1hdHJpeENvbHVtbihvYmplY3RNYXRyaXgsIDApO1xuICAgICAgICAgIHYuY3Jvc3NWZWN0b3JzKHNjb3BlLm9iamVjdC51cCwgdik7XG4gICAgICAgIH1cbiAgICAgICAgdi5tdWx0aXBseVNjYWxhcihkaXN0YW5jZSk7XG4gICAgICAgIHBhbk9mZnNldC5hZGQodik7XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgY29uc3QgcGFuID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcGFuMihkZWx0YVgsIGRlbHRhWSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEpIHtcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHNjb3BlLm9iamVjdC5wb3NpdGlvbjtcbiAgICAgICAgICBvZmZzZXQuY29weShwb3NpdGlvbikuc3ViKHNjb3BlLnRhcmdldCk7XG4gICAgICAgICAgbGV0IHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuICAgICAgICAgIHRhcmdldERpc3RhbmNlICo9IE1hdGgudGFuKHNjb3BlLm9iamVjdC5mb3YgLyAyICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgcGFuTGVmdCgyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCk7XG4gICAgICAgICAgcGFuVXAoMiAqIGRlbHRhWSAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXgpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgJiYgc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICAgIHBhbkxlZnQoXG4gICAgICAgICAgICBkZWx0YVggKiAoc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQpIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgc2NvcGUub2JqZWN0Lm1hdHJpeFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGFuVXAoXG4gICAgICAgICAgICBkZWx0YVkgKiAoc2NvcGUub2JqZWN0LnRvcCAtIHNjb3BlLm9iamVjdC5ib3R0b20pIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC5tYXRyaXhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC5cIik7XG4gICAgICAgICAgc2NvcGUuZW5hYmxlUGFuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBmdW5jdGlvbiBkb2xseU91dChkb2xseVNjYWxlKSB7XG4gICAgICBpZiAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgfHwgc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICBzY2FsZSAvPSBkb2xseVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC5cIik7XG4gICAgICAgIHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZG9sbHlJbihkb2xseVNjYWxlKSB7XG4gICAgICBpZiAoc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgfHwgc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICBzY2FsZSAqPSBkb2xseVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC5cIik7XG4gICAgICAgIHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlTW91c2VQYXJhbWV0ZXJzKGV2ZW50KSB7XG4gICAgICBpZiAoIXNjb3BlLnpvb21Ub0N1cnNvciB8fCAhc2NvcGUuZG9tRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwZXJmb3JtQ3Vyc29yWm9vbSA9IHRydWU7XG4gICAgICBjb25zdCByZWN0ID0gc2NvcGUuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgIGNvbnN0IHcgPSByZWN0LndpZHRoO1xuICAgICAgY29uc3QgaCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgbW91c2UueCA9IHggLyB3ICogMiAtIDE7XG4gICAgICBtb3VzZS55ID0gLSh5IC8gaCkgKiAyICsgMTtcbiAgICAgIGRvbGx5RGlyZWN0aW9uLnNldChtb3VzZS54LCBtb3VzZS55LCAxKS51bnByb2plY3Qoc2NvcGUub2JqZWN0KS5zdWIoc2NvcGUub2JqZWN0LnBvc2l0aW9uKS5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhbXBEaXN0YW5jZShkaXN0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoc2NvcGUubWluRGlzdGFuY2UsIE1hdGgubWluKHNjb3BlLm1heERpc3RhbmNlLCBkaXN0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blJvdGF0ZShldmVudCkge1xuICAgICAgcm90YXRlU3RhcnQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Eb2xseShldmVudCkge1xuICAgICAgdXBkYXRlTW91c2VQYXJhbWV0ZXJzKGV2ZW50KTtcbiAgICAgIGRvbGx5U3RhcnQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25QYW4oZXZlbnQpIHtcbiAgICAgIHBhblN0YXJ0LnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUm90YXRlKGV2ZW50KSB7XG4gICAgICByb3RhdGVFbmQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyhyb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5yb3RhdGVTcGVlZCk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJvdGF0ZUxlZnQoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICByb3RhdGVVcCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB9XG4gICAgICByb3RhdGVTdGFydC5jb3B5KHJvdGF0ZUVuZCk7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlRG9sbHkoZXZlbnQpIHtcbiAgICAgIGRvbGx5RW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIGRvbGx5RGVsdGEuc3ViVmVjdG9ycyhkb2xseUVuZCwgZG9sbHlTdGFydCk7XG4gICAgICBpZiAoZG9sbHlEZWx0YS55ID4gMCkge1xuICAgICAgICBkb2xseU91dChnZXRab29tU2NhbGUoKSk7XG4gICAgICB9IGVsc2UgaWYgKGRvbGx5RGVsdGEueSA8IDApIHtcbiAgICAgICAgZG9sbHlJbihnZXRab29tU2NhbGUoKSk7XG4gICAgICB9XG4gICAgICBkb2xseVN0YXJ0LmNvcHkoZG9sbHlFbmQpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVBhbihldmVudCkge1xuICAgICAgcGFuRW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIHBhbkRlbHRhLnN1YlZlY3RvcnMocGFuRW5kLCBwYW5TdGFydCkubXVsdGlwbHlTY2FsYXIoc2NvcGUucGFuU3BlZWQpO1xuICAgICAgcGFuKHBhbkRlbHRhLngsIHBhbkRlbHRhLnkpO1xuICAgICAgcGFuU3RhcnQuY29weShwYW5FbmQpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICAgIHVwZGF0ZU1vdXNlUGFyYW1ldGVycyhldmVudCk7XG4gICAgICBpZiAoZXZlbnQuZGVsdGFZIDwgMCkge1xuICAgICAgICBkb2xseUluKGdldFpvb21TY2FsZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGVsdGFZID4gMCkge1xuICAgICAgICBkb2xseU91dChnZXRab29tU2NhbGUoKSk7XG4gICAgICB9XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmNvZGUpIHtcbiAgICAgICAgY2FzZSBzY29wZS5rZXlzLlVQOlxuICAgICAgICAgIHBhbigwLCBzY29wZS5rZXlQYW5TcGVlZCk7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuICAgICAgICAgIHBhbigwLCAtc2NvcGUua2V5UGFuU3BlZWQpO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzY29wZS5rZXlzLkxFRlQ6XG4gICAgICAgICAgcGFuKHNjb3BlLmtleVBhblNwZWVkLCAwKTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc2NvcGUua2V5cy5SSUdIVDpcbiAgICAgICAgICBwYW4oLXNjb3BlLmtleVBhblNwZWVkLCAwKTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoKSB7XG4gICAgICBpZiAocG9pbnRlcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcm90YXRlU3RhcnQuc2V0KHBvaW50ZXJzWzBdLnBhZ2VYLCBwb2ludGVyc1swXS5wYWdlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB4ID0gMC41ICogKHBvaW50ZXJzWzBdLnBhZ2VYICsgcG9pbnRlcnNbMV0ucGFnZVgpO1xuICAgICAgICBjb25zdCB5ID0gMC41ICogKHBvaW50ZXJzWzBdLnBhZ2VZICsgcG9pbnRlcnNbMV0ucGFnZVkpO1xuICAgICAgICByb3RhdGVTdGFydC5zZXQoeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRQYW4oKSB7XG4gICAgICBpZiAocG9pbnRlcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcGFuU3RhcnQuc2V0KHBvaW50ZXJzWzBdLnBhZ2VYLCBwb2ludGVyc1swXS5wYWdlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB4ID0gMC41ICogKHBvaW50ZXJzWzBdLnBhZ2VYICsgcG9pbnRlcnNbMV0ucGFnZVgpO1xuICAgICAgICBjb25zdCB5ID0gMC41ICogKHBvaW50ZXJzWzBdLnBhZ2VZICsgcG9pbnRlcnNbMV0ucGFnZVkpO1xuICAgICAgICBwYW5TdGFydC5zZXQoeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseSgpIHtcbiAgICAgIGNvbnN0IGR4ID0gcG9pbnRlcnNbMF0ucGFnZVggLSBwb2ludGVyc1sxXS5wYWdlWDtcbiAgICAgIGNvbnN0IGR5ID0gcG9pbnRlcnNbMF0ucGFnZVkgLSBwb2ludGVyc1sxXS5wYWdlWTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGRvbGx5U3RhcnQuc2V0KDAsIGRpc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5UGFuKCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20pXG4gICAgICAgIGhhbmRsZVRvdWNoU3RhcnREb2xseSgpO1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbilcbiAgICAgICAgaGFuZGxlVG91Y2hTdGFydFBhbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlSb3RhdGUoKSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSlcbiAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5KCk7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlKVxuICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZShldmVudCkge1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJvdGF0ZUVuZC5zZXQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChldmVudC5wYWdlWCArIHBvc2l0aW9uLngpO1xuICAgICAgICBjb25zdCB5ID0gMC41ICogKGV2ZW50LnBhZ2VZICsgcG9zaXRpb24ueSk7XG4gICAgICAgIHJvdGF0ZUVuZC5zZXQoeCwgeSk7XG4gICAgICB9XG4gICAgICByb3RhdGVEZWx0YS5zdWJWZWN0b3JzKHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQpLm11bHRpcGx5U2NhbGFyKHNjb3BlLnJvdGF0ZVNwZWVkKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcm90YXRlTGVmdCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgIHJvdGF0ZVVwKDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJvdGF0ZVN0YXJ0LmNvcHkocm90YXRlRW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUGFuKGV2ZW50KSB7XG4gICAgICBpZiAocG9pbnRlcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcGFuRW5kLnNldChldmVudC5wYWdlWCwgZXZlbnQucGFnZVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICBjb25zdCB4ID0gMC41ICogKGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCk7XG4gICAgICAgIGNvbnN0IHkgPSAwLjUgKiAoZXZlbnQucGFnZVkgKyBwb3NpdGlvbi55KTtcbiAgICAgICAgcGFuRW5kLnNldCh4LCB5KTtcbiAgICAgIH1cbiAgICAgIHBhbkRlbHRhLnN1YlZlY3RvcnMocGFuRW5kLCBwYW5TdGFydCkubXVsdGlwbHlTY2FsYXIoc2NvcGUucGFuU3BlZWQpO1xuICAgICAgcGFuKHBhbkRlbHRhLngsIHBhbkRlbHRhLnkpO1xuICAgICAgcGFuU3RhcnQuY29weShwYW5FbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseShldmVudCkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oZXZlbnQpO1xuICAgICAgY29uc3QgZHggPSBldmVudC5wYWdlWCAtIHBvc2l0aW9uLng7XG4gICAgICBjb25zdCBkeSA9IGV2ZW50LnBhZ2VZIC0gcG9zaXRpb24ueTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGRvbGx5RW5kLnNldCgwLCBkaXN0YW5jZSk7XG4gICAgICBkb2xseURlbHRhLnNldCgwLCBNYXRoLnBvdyhkb2xseUVuZC55IC8gZG9sbHlTdGFydC55LCBzY29wZS56b29tU3BlZWQpKTtcbiAgICAgIGRvbGx5T3V0KGRvbGx5RGVsdGEueSk7XG4gICAgICBkb2xseVN0YXJ0LmNvcHkoZG9sbHlFbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseVBhbihldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20pXG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5KGV2ZW50KTtcbiAgICAgIGlmIChzY29wZS5lbmFibGVQYW4pXG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZVBhbihldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5Um90YXRlKGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSlcbiAgICAgICAgaGFuZGxlVG91Y2hNb3ZlRG9sbHkoZXZlbnQpO1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSlcbiAgICAgICAgaGFuZGxlVG91Y2hNb3ZlUm90YXRlKGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAoX2EgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Eub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIChfYiA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXApO1xuICAgICAgfVxuICAgICAgYWRkUG9pbnRlcihldmVudCk7XG4gICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICBvblRvdWNoU3RhcnQoZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Nb3VzZURvd24oZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgIG9uVG91Y2hNb3ZlKGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgcmVtb3ZlUG9pbnRlcihldmVudCk7XG4gICAgICBpZiAocG9pbnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIChfYSA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgKF9iID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICAoX2MgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Mub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwKTtcbiAgICAgIH1cbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgbGV0IG1vdXNlQWN0aW9uO1xuICAgICAgc3dpdGNoIChldmVudC5idXR0b24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG1vdXNlQWN0aW9uID0gc2NvcGUubW91c2VCdXR0b25zLkxFRlQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtb3VzZUFjdGlvbiA9IHNjb3BlLm1vdXNlQnV0dG9ucy5NSURETEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtb3VzZUFjdGlvbiA9IHNjb3BlLm1vdXNlQnV0dG9ucy5SSUdIVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBtb3VzZUFjdGlvbiA9IC0xO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChtb3VzZUFjdGlvbikge1xuICAgICAgICBjYXNlIE1PVVNFLkRPTExZOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVNb3VzZURvd25Eb2xseShldmVudCk7XG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5ET0xMWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNT1VTRS5ST1RBVEU6XG4gICAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRG93blBhbihldmVudCk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlBBTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRG93blJvdGF0ZShldmVudCk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlJPVEFURTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTU9VU0UuUEFOOlxuICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25Sb3RhdGUoZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5ST1RBVEU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25QYW4oZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5QQU47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xuICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgU1RBVEUuUk9UQVRFOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZShldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEUuRE9MTFk6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZURvbGx5KGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURS5QQU46XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlUGFuKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgfHwgc3RhdGUgIT09IFNUQVRFLk5PTkUgJiYgc3RhdGUgIT09IFNUQVRFLlJPVEFURSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICAgIGhhbmRsZU1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGhhbmRsZUtleURvd24oZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIHRyYWNrUG9pbnRlcihldmVudCk7XG4gICAgICBzd2l0Y2ggKHBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgc3dpdGNoIChzY29wZS50b3VjaGVzLk9ORSkge1xuICAgICAgICAgICAgY2FzZSBUT1VDSC5ST1RBVEU6XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSgpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRPVUNILlBBTjpcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0UGFuKCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzd2l0Y2ggKHNjb3BlLnRvdWNoZXMuVFdPKSB7XG4gICAgICAgICAgICBjYXNlIFRPVUNILkRPTExZX1BBTjpcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlQYW4oKTtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWV9QQU47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUT1VDSC5ET0xMWV9ST1RBVEU6XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5Um90YXRlKCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFlfUk9UQVRFO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5OT05FKSB7XG4gICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgICB0cmFja1BvaW50ZXIoZXZlbnQpO1xuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFNUQVRFLlRPVUNIX1JPVEFURTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoZXZlbnQpO1xuICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFLlRPVUNIX1BBTjpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVQYW4oZXZlbnQpO1xuICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFLlRPVUNIX0RPTExZX1BBTjpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseVBhbihldmVudCk7XG4gICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEUuVE9VQ0hfRE9MTFlfUk9UQVRFOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5Um90YXRlKGV2ZW50KTtcbiAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkUG9pbnRlcihldmVudCkge1xuICAgICAgcG9pbnRlcnMucHVzaChldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIGRlbGV0ZSBwb2ludGVyUG9zaXRpb25zW2V2ZW50LnBvaW50ZXJJZF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwb2ludGVyc1tpXS5wb2ludGVySWQgPT0gZXZlbnQucG9pbnRlcklkKSB7XG4gICAgICAgICAgcG9pbnRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFja1BvaW50ZXIoZXZlbnQpIHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IHBvaW50ZXJQb3NpdGlvbnNbZXZlbnQucG9pbnRlcklkXTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBvc2l0aW9uID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgICAgcG9pbnRlclBvc2l0aW9uc1tldmVudC5wb2ludGVySWRdID0gcG9zaXRpb247XG4gICAgICB9XG4gICAgICBwb3NpdGlvbi5zZXQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICBjb25zdCBwb2ludGVyID0gZXZlbnQucG9pbnRlcklkID09PSBwb2ludGVyc1swXS5wb2ludGVySWQgPyBwb2ludGVyc1sxXSA6IHBvaW50ZXJzWzBdO1xuICAgICAgcmV0dXJuIHBvaW50ZXJQb3NpdGlvbnNbcG9pbnRlci5wb2ludGVySWRdO1xuICAgIH1cbiAgICBpZiAoZG9tRWxlbWVudCAhPT0gdm9pZCAwKVxuICAgICAgdGhpcy5jb25uZWN0KGRvbUVsZW1lbnQpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbn1cbmNsYXNzIE1hcENvbnRyb2xzIGV4dGVuZHMgT3JiaXRDb250cm9scyB7XG4gIGNvbnN0cnVjdG9yKG9iamVjdCwgZG9tRWxlbWVudCkge1xuICAgIHN1cGVyKG9iamVjdCwgZG9tRWxlbWVudCk7XG4gICAgdGhpcy5zY3JlZW5TcGFjZVBhbm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5MRUZUID0gTU9VU0UuUEFOO1xuICAgIHRoaXMubW91c2VCdXR0b25zLlJJR0hUID0gTU9VU0UuUk9UQVRFO1xuICAgIHRoaXMudG91Y2hlcy5PTkUgPSBUT1VDSC5QQU47XG4gICAgdGhpcy50b3VjaGVzLlRXTyA9IFRPVUNILkRPTExZX1JPVEFURTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgTWFwQ29udHJvbHMsXG4gIE9yYml0Q29udHJvbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcmJpdENvbnRyb2xzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/MTLLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/MTLLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MTLLoader: () => (/* binding */ MTLLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass MTLLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split(\"\\n\");\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      }\n      const pos = line.indexOf(\" \");\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : \"\";\n      value = value.trim();\n      if (key === \"newmtl\") {\n        info = { name: value };\n        materialsInfo[value] = info;\n      } else {\n        if (key === \"ka\" || key === \"kd\" || key === \"ks\" || key === \"ke\") {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n}\nclass MaterialCreator {\n  constructor(baseUrl = \"\", options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = \"anonymous\";\n    this.side = this.options.side !== void 0 ? this.options.side : three__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n  }\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n  setManager(value) {\n    this.manager = value;\n  }\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n  convert(materialsInfo) {\n    if (!this.options)\n      return materialsInfo;\n    const converted = {};\n    for (const mn in materialsInfo) {\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n        switch (lprop) {\n          case \"kd\":\n          case \"ka\":\n          case \"ks\":\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                save = false;\n              }\n            }\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  }\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n  getAsArray() {\n    let index = 0;\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  }\n  create(materialName) {\n    if (this.materials[materialName] === void 0) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  }\n  createMaterial_(materialName) {\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url) {\n      if (typeof url !== \"string\" || url === \"\")\n        return \"\";\n      if (/^https?:\\/\\//i.test(url))\n        return url;\n      return baseUrl + url;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType])\n        return;\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      params[mapType] = map;\n    }\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === \"\")\n        continue;\n      switch (prop.toLowerCase()) {\n        case \"kd\":\n          params.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(value);\n          break;\n        case \"ks\":\n          params.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(value);\n          break;\n        case \"ke\":\n          params.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(value);\n          break;\n        case \"map_kd\":\n          setMapForType(\"map\", value);\n          break;\n        case \"map_ks\":\n          setMapForType(\"specularMap\", value);\n          break;\n        case \"map_ke\":\n          setMapForType(\"emissiveMap\", value);\n          break;\n        case \"norm\":\n          setMapForType(\"normalMap\", value);\n          break;\n        case \"map_bump\":\n        case \"bump\":\n          setMapForType(\"bumpMap\", value);\n          break;\n        case \"map_d\":\n          setMapForType(\"alphaMap\", value);\n          params.transparent = true;\n          break;\n        case \"ns\":\n          params.shininess = parseFloat(value);\n          break;\n        case \"d\":\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case \"tr\":\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty)\n            n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n      }\n    }\n    this.materials[materialName] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),\n      offset: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf(\"-bm\");\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf(\"-s\");\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    pos = items.indexOf(\"-o\");\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    texParams.url = items.join(\" \").trim();\n    return texParams;\n  }\n  loadTexture(url, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== void 0 ? this.manager : three__WEBPACK_IMPORTED_MODULE_0__.DefaultLoadingManager;\n    let loader = manager.getHandler(url);\n    if (loader === null) {\n      loader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin)\n      loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url, onLoad, onProgress, onError);\n    if (mapping !== void 0)\n      texture.mapping = mapping;\n    return texture;\n  }\n}\n\n//# sourceMappingURL=MTLLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvTVRMTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRKO0FBQzVKLHdCQUF3Qix5Q0FBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBVztBQUMvQyx1QkFBdUIsNkNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw0Q0FBUztBQUM1RSxtRUFBbUUsaURBQWM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdDQUFLO0FBQ2xDO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQUs7QUFDckM7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0RBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUFPO0FBQ3hCLGtCQUFrQiwwQ0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3REFBcUI7QUFDbEY7QUFDQTtBQUNBLG1CQUFtQixnREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWV0YTM2MC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9NVExMb2FkZXIuanM/ZWU2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIExvYWRlclV0aWxzLCBGaWxlTG9hZGVyLCBGcm9udFNpZGUsIFJlcGVhdFdyYXBwaW5nLCBDb2xvciwgTWVzaFBob25nTWF0ZXJpYWwsIFZlY3RvcjIsIERlZmF1bHRMb2FkaW5nTWFuYWdlciwgVGV4dHVyZUxvYWRlciB9IGZyb20gXCJ0aHJlZVwiO1xuY2xhc3MgTVRMTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBhbmQgcGFyc2VzIGEgTVRMIGFzc2V0IGZyb20gYSBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBVUkwgdG8gdGhlIE1UTCBmaWxlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Mb2FkXSAtIENhbGxiYWNrIGludm9rZWQgd2l0aCB0aGUgbG9hZGVkIG9iamVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQ2FsbGJhY2sgZm9yIGRvd25sb2FkIHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBDYWxsYmFjayBmb3IgZG93bmxvYWQgZXJyb3JzLlxuICAgKlxuICAgKiBAc2VlIHNldFBhdGggc2V0UmVzb3VyY2VQYXRoXG4gICAqXG4gICAqIEBub3RlIEluIG9yZGVyIGZvciByZWxhdGl2ZSB0ZXh0dXJlIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZSBjb3JyZWN0bHlcbiAgICogeW91IG11c3QgY2FsbCBzZXRSZXNvdXJjZVBhdGgoKSBleHBsaWNpdGx5IHByaW9yIHRvIGxvYWQuXG4gICAqL1xuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGggPT09IFwiXCIgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpIDogdGhpcy5wYXRoO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIGxvYWRlci5sb2FkKFxuICAgICAgdXJsLFxuICAgICAgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9uTG9hZChzY29wZS5wYXJzZSh0ZXh0LCBwYXRoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbkVycm9yXG4gICAgKTtcbiAgfVxuICBzZXRNYXRlcmlhbE9wdGlvbnModmFsdWUpIHtcbiAgICB0aGlzLm1hdGVyaWFsT3B0aW9ucyA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBNVEwgZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBDb250ZW50IG9mIE1UTCBmaWxlXG4gICAqIEByZXR1cm4ge01hdGVyaWFsQ3JlYXRvcn1cbiAgICpcbiAgICogQHNlZSBzZXRQYXRoIHNldFJlc291cmNlUGF0aFxuICAgKlxuICAgKiBAbm90ZSBJbiBvcmRlciBmb3IgcmVsYXRpdmUgdGV4dHVyZSByZWZlcmVuY2VzIHRvIHJlc29sdmUgY29ycmVjdGx5XG4gICAqIHlvdSBtdXN0IGNhbGwgc2V0UmVzb3VyY2VQYXRoKCkgZXhwbGljaXRseSBwcmlvciB0byBwYXJzZS5cbiAgICovXG4gIHBhcnNlKHRleHQsIHBhdGgpIHtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgbGV0IGluZm8gPSB7fTtcbiAgICBjb25zdCBkZWxpbWl0ZXJfcGF0dGVybiA9IC9cXHMrLztcbiAgICBjb25zdCBtYXRlcmlhbHNJbmZvID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCB8fCBsaW5lLmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3MgPSBsaW5lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgbGV0IGtleSA9IHBvcyA+PSAwID8gbGluZS5zdWJzdHJpbmcoMCwgcG9zKSA6IGxpbmU7XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGxldCB2YWx1ZSA9IHBvcyA+PSAwID8gbGluZS5zdWJzdHJpbmcocG9zICsgMSkgOiBcIlwiO1xuICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICBpZiAoa2V5ID09PSBcIm5ld210bFwiKSB7XG4gICAgICAgIGluZm8gPSB7IG5hbWU6IHZhbHVlIH07XG4gICAgICAgIG1hdGVyaWFsc0luZm9bdmFsdWVdID0gaW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwia2FcIiB8fCBrZXkgPT09IFwia2RcIiB8fCBrZXkgPT09IFwia3NcIiB8fCBrZXkgPT09IFwia2VcIikge1xuICAgICAgICAgIGNvbnN0IHNzID0gdmFsdWUuc3BsaXQoZGVsaW1pdGVyX3BhdHRlcm4sIDMpO1xuICAgICAgICAgIGluZm9ba2V5XSA9IFtwYXJzZUZsb2F0KHNzWzBdKSwgcGFyc2VGbG9hdChzc1sxXSksIHBhcnNlRmxvYXQoc3NbMl0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmZvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXRlcmlhbENyZWF0b3IgPSBuZXcgTWF0ZXJpYWxDcmVhdG9yKHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGgsIHRoaXMubWF0ZXJpYWxPcHRpb25zKTtcbiAgICBtYXRlcmlhbENyZWF0b3Iuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7XG4gICAgbWF0ZXJpYWxDcmVhdG9yLnNldE1hbmFnZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBtYXRlcmlhbENyZWF0b3Iuc2V0TWF0ZXJpYWxzKG1hdGVyaWFsc0luZm8pO1xuICAgIHJldHVybiBtYXRlcmlhbENyZWF0b3I7XG4gIH1cbn1cbmNsYXNzIE1hdGVyaWFsQ3JlYXRvciB7XG4gIGNvbnN0cnVjdG9yKGJhc2VVcmwgPSBcIlwiLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5tYXRlcmlhbHNJbmZvID0ge307XG4gICAgdGhpcy5tYXRlcmlhbHMgPSB7fTtcbiAgICB0aGlzLm1hdGVyaWFsc0FycmF5ID0gW107XG4gICAgdGhpcy5uYW1lTG9va3VwID0ge307XG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgdGhpcy5zaWRlID0gdGhpcy5vcHRpb25zLnNpZGUgIT09IHZvaWQgMCA/IHRoaXMub3B0aW9ucy5zaWRlIDogRnJvbnRTaWRlO1xuICAgIHRoaXMud3JhcCA9IHRoaXMub3B0aW9ucy53cmFwICE9PSB2b2lkIDAgPyB0aGlzLm9wdGlvbnMud3JhcCA6IFJlcGVhdFdyYXBwaW5nO1xuICB9XG4gIHNldENyb3NzT3JpZ2luKHZhbHVlKSB7XG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldE1hbmFnZXIodmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSB2YWx1ZTtcbiAgfVxuICBzZXRNYXRlcmlhbHMobWF0ZXJpYWxzSW5mbykge1xuICAgIHRoaXMubWF0ZXJpYWxzSW5mbyA9IHRoaXMuY29udmVydChtYXRlcmlhbHNJbmZvKTtcbiAgICB0aGlzLm1hdGVyaWFscyA9IHt9O1xuICAgIHRoaXMubWF0ZXJpYWxzQXJyYXkgPSBbXTtcbiAgICB0aGlzLm5hbWVMb29rdXAgPSB7fTtcbiAgfVxuICBjb252ZXJ0KG1hdGVyaWFsc0luZm8pIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucylcbiAgICAgIHJldHVybiBtYXRlcmlhbHNJbmZvO1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgbW4gaW4gbWF0ZXJpYWxzSW5mbykge1xuICAgICAgY29uc3QgbWF0ID0gbWF0ZXJpYWxzSW5mb1ttbl07XG4gICAgICBjb25zdCBjb3ZtYXQgPSB7fTtcbiAgICAgIGNvbnZlcnRlZFttbl0gPSBjb3ZtYXQ7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gbWF0KSB7XG4gICAgICAgIGxldCBzYXZlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHZhbHVlID0gbWF0W3Byb3BdO1xuICAgICAgICBjb25zdCBscHJvcCA9IHByb3AudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoIChscHJvcCkge1xuICAgICAgICAgIGNhc2UgXCJrZFwiOlxuICAgICAgICAgIGNhc2UgXCJrYVwiOlxuICAgICAgICAgIGNhc2UgXCJrc1wiOlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubm9ybWFsaXplUkdCKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlWzBdIC8gMjU1LCB2YWx1ZVsxXSAvIDI1NSwgdmFsdWVbMl0gLyAyNTVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaWdub3JlWmVyb1JHQnMpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSAwICYmIHZhbHVlWzFdID09PSAwICYmIHZhbHVlWzJdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2F2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2F2ZSkge1xuICAgICAgICAgIGNvdm1hdFtscHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xuICB9XG4gIHByZWxvYWQoKSB7XG4gICAgZm9yIChjb25zdCBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8pIHtcbiAgICAgIHRoaXMuY3JlYXRlKG1uKTtcbiAgICB9XG4gIH1cbiAgZ2V0SW5kZXgobWF0ZXJpYWxOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZUxvb2t1cFttYXRlcmlhbE5hbWVdO1xuICB9XG4gIGdldEFzQXJyYXkoKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG1uIGluIHRoaXMubWF0ZXJpYWxzSW5mbykge1xuICAgICAgdGhpcy5tYXRlcmlhbHNBcnJheVtpbmRleF0gPSB0aGlzLmNyZWF0ZShtbik7XG4gICAgICB0aGlzLm5hbWVMb29rdXBbbW5dID0gaW5kZXg7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbHNBcnJheTtcbiAgfVxuICBjcmVhdGUobWF0ZXJpYWxOYW1lKSB7XG4gICAgaWYgKHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jcmVhdGVNYXRlcmlhbF8obWF0ZXJpYWxOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsTmFtZV07XG4gIH1cbiAgY3JlYXRlTWF0ZXJpYWxfKG1hdGVyaWFsTmFtZSkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBjb25zdCBtYXQgPSB0aGlzLm1hdGVyaWFsc0luZm9bbWF0ZXJpYWxOYW1lXTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBuYW1lOiBtYXRlcmlhbE5hbWUsXG4gICAgICBzaWRlOiB0aGlzLnNpZGVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwoYmFzZVVybCwgdXJsKSB7XG4gICAgICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiB8fCB1cmwgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QodXJsKSlcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIHJldHVybiBiYXNlVXJsICsgdXJsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRNYXBGb3JUeXBlKG1hcFR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAocGFyYW1zW21hcFR5cGVdKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0ZXhQYXJhbXMgPSBzY29wZS5nZXRUZXh0dXJlUGFyYW1zKHZhbHVlLCBwYXJhbXMpO1xuICAgICAgY29uc3QgbWFwID0gc2NvcGUubG9hZFRleHR1cmUocmVzb2x2ZVVSTChzY29wZS5iYXNlVXJsLCB0ZXhQYXJhbXMudXJsKSk7XG4gICAgICBtYXAucmVwZWF0LmNvcHkodGV4UGFyYW1zLnNjYWxlKTtcbiAgICAgIG1hcC5vZmZzZXQuY29weSh0ZXhQYXJhbXMub2Zmc2V0KTtcbiAgICAgIG1hcC53cmFwUyA9IHNjb3BlLndyYXA7XG4gICAgICBtYXAud3JhcFQgPSBzY29wZS53cmFwO1xuICAgICAgcGFyYW1zW21hcFR5cGVdID0gbWFwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gbWF0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1hdFtwcm9wXTtcbiAgICAgIGxldCBuO1xuICAgICAgaWYgKHZhbHVlID09PSBcIlwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAocHJvcC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJrZFwiOlxuICAgICAgICAgIHBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJrc1wiOlxuICAgICAgICAgIHBhcmFtcy5zcGVjdWxhciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJrZVwiOlxuICAgICAgICAgIHBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheSh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBfa2RcIjpcbiAgICAgICAgICBzZXRNYXBGb3JUeXBlKFwibWFwXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hcF9rc1wiOlxuICAgICAgICAgIHNldE1hcEZvclR5cGUoXCJzcGVjdWxhck1hcFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBfa2VcIjpcbiAgICAgICAgICBzZXRNYXBGb3JUeXBlKFwiZW1pc3NpdmVNYXBcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm9ybVwiOlxuICAgICAgICAgIHNldE1hcEZvclR5cGUoXCJub3JtYWxNYXBcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFwX2J1bXBcIjpcbiAgICAgICAgY2FzZSBcImJ1bXBcIjpcbiAgICAgICAgICBzZXRNYXBGb3JUeXBlKFwiYnVtcE1hcFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBfZFwiOlxuICAgICAgICAgIHNldE1hcEZvclR5cGUoXCJhbHBoYU1hcFwiLCB2YWx1ZSk7XG4gICAgICAgICAgcGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5zXCI6XG4gICAgICAgICAgcGFyYW1zLnNoaW5pbmVzcyA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgICAgIHBhcmFtcy5vcGFjaXR5ID0gbjtcbiAgICAgICAgICAgIHBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidHJcIjpcbiAgICAgICAgICBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaW52ZXJ0VHJQcm9wZXJ0eSlcbiAgICAgICAgICAgIG4gPSAxIC0gbjtcbiAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHBhcmFtcy5vcGFjaXR5ID0gMSAtIG47XG4gICAgICAgICAgICBwYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXRlcmlhbHNbbWF0ZXJpYWxOYW1lXSA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbChwYXJhbXMpO1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsc1ttYXRlcmlhbE5hbWVdO1xuICB9XG4gIGdldFRleHR1cmVQYXJhbXModmFsdWUsIG1hdFBhcmFtcykge1xuICAgIGNvbnN0IHRleFBhcmFtcyA9IHtcbiAgICAgIHNjYWxlOiBuZXcgVmVjdG9yMigxLCAxKSxcbiAgICAgIG9mZnNldDogbmV3IFZlY3RvcjIoMCwgMClcbiAgICB9O1xuICAgIGNvbnN0IGl0ZW1zID0gdmFsdWUuc3BsaXQoL1xccysvKTtcbiAgICBsZXQgcG9zO1xuICAgIHBvcyA9IGl0ZW1zLmluZGV4T2YoXCItYm1cIik7XG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICBtYXRQYXJhbXMuYnVtcFNjYWxlID0gcGFyc2VGbG9hdChpdGVtc1twb3MgKyAxXSk7XG4gICAgICBpdGVtcy5zcGxpY2UocG9zLCAyKTtcbiAgICB9XG4gICAgcG9zID0gaXRlbXMuaW5kZXhPZihcIi1zXCIpO1xuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgdGV4UGFyYW1zLnNjYWxlLnNldChwYXJzZUZsb2F0KGl0ZW1zW3BvcyArIDFdKSwgcGFyc2VGbG9hdChpdGVtc1twb3MgKyAyXSkpO1xuICAgICAgaXRlbXMuc3BsaWNlKHBvcywgNCk7XG4gICAgfVxuICAgIHBvcyA9IGl0ZW1zLmluZGV4T2YoXCItb1wiKTtcbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIHRleFBhcmFtcy5vZmZzZXQuc2V0KHBhcnNlRmxvYXQoaXRlbXNbcG9zICsgMV0pLCBwYXJzZUZsb2F0KGl0ZW1zW3BvcyArIDJdKSk7XG4gICAgICBpdGVtcy5zcGxpY2UocG9zLCA0KTtcbiAgICB9XG4gICAgdGV4UGFyYW1zLnVybCA9IGl0ZW1zLmpvaW4oXCIgXCIpLnRyaW0oKTtcbiAgICByZXR1cm4gdGV4UGFyYW1zO1xuICB9XG4gIGxvYWRUZXh0dXJlKHVybCwgbWFwcGluZywgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHRoaXMubWFuYWdlciAhPT0gdm9pZCAwID8gdGhpcy5tYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuICAgIGxldCBsb2FkZXIgPSBtYW5hZ2VyLmdldEhhbmRsZXIodXJsKTtcbiAgICBpZiAobG9hZGVyID09PSBudWxsKSB7XG4gICAgICBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcihtYW5hZ2VyKTtcbiAgICB9XG4gICAgaWYgKGxvYWRlci5zZXRDcm9zc09yaWdpbilcbiAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbG9hZGVyLmxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICAgIGlmIChtYXBwaW5nICE9PSB2b2lkIDApXG4gICAgICB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG59XG5leHBvcnQge1xuICBNVExMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NVExMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/MTLLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/OBJLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/OBJLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OBJLoader: () => (/* binding */ OBJLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _object_pattern = /^[og]\\s*(.+)?/;\nconst _material_library_pattern = /^mtllib /;\nconst _material_use_pattern = /^usemtl /;\nconst _map_use_pattern = /^usemap /;\nconst _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _ab = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _cb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n    materials: {},\n    materialLibraries: [],\n    startObject: function(name, fromDeclaration) {\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name;\n        this.object.fromDeclaration = fromDeclaration !== false;\n        return;\n      }\n      const previousMaterial = this.object && typeof this.object.currentMaterial === \"function\" ? this.object.currentMaterial() : void 0;\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n      this.object = {\n        name: name || \"\",\n        fromDeclaration: fromDeclaration !== false,\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false\n        },\n        materials: [],\n        smooth: true,\n        startMaterial: function(name2, libraries) {\n          const previous = this._finalize(false);\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1);\n          }\n          const material = {\n            index: this.materials.length,\n            name: name2 || \"\",\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : \"\",\n            smooth: previous !== void 0 ? previous.smooth : this.smooth,\n            groupStart: previous !== void 0 ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n            clone: function(index) {\n              const cloned = {\n                index: typeof index === \"number\" ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false\n              };\n              cloned.clone = this.clone.bind(cloned);\n              return cloned;\n            }\n          };\n          this.materials.push(material);\n          return material;\n        },\n        currentMaterial: function() {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1];\n          }\n          return void 0;\n        },\n        _finalize: function(end) {\n          const lastMultiMaterial = this.currentMaterial();\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n            lastMultiMaterial.inherited = false;\n          }\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1);\n              }\n            }\n          }\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: \"\",\n              smooth: this.smooth\n            });\n          }\n          return lastMultiMaterial;\n        }\n      };\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\") {\n        const declared = previousMaterial.clone(0);\n        declared.inherited = true;\n        this.object.materials.push(declared);\n      }\n      this.objects.push(this.object);\n    },\n    finalize: function() {\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n    },\n    parseVertexIndex: function(value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseNormalIndex: function(value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseUVIndex: function(value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 2) * 2;\n    },\n    addVertex: function(a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addVertexPoint: function(a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addVertexLine: function(a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addNormal: function(a, b, c) {\n      const src = this.normals;\n      const dst = this.object.geometry.normals;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addFaceNormal: function(a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.normals;\n      _vA.fromArray(src, a);\n      _vB.fromArray(src, b);\n      _vC.fromArray(src, c);\n      _cb.subVectors(_vC, _vB);\n      _ab.subVectors(_vA, _vB);\n      _cb.cross(_ab);\n      _cb.normalize();\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n    },\n    addColor: function(a, b, c) {\n      const src = this.colors;\n      const dst = this.object.geometry.colors;\n      if (src[a] !== void 0)\n        dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      if (src[b] !== void 0)\n        dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      if (src[c] !== void 0)\n        dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addUV: function(a, b, c) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n      dst.push(src[b + 0], src[b + 1]);\n      dst.push(src[c + 0], src[c + 1]);\n    },\n    addDefaultUV: function() {\n      const dst = this.object.geometry.uvs;\n      dst.push(0, 0);\n      dst.push(0, 0);\n      dst.push(0, 0);\n    },\n    addUVLine: function(a) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n    },\n    addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length;\n      let ia = this.parseVertexIndex(a, vLen);\n      let ib = this.parseVertexIndex(b, vLen);\n      let ic = this.parseVertexIndex(c, vLen);\n      this.addVertex(ia, ib, ic);\n      this.addColor(ia, ib, ic);\n      if (na !== void 0 && na !== \"\") {\n        const nLen = this.normals.length;\n        ia = this.parseNormalIndex(na, nLen);\n        ib = this.parseNormalIndex(nb, nLen);\n        ic = this.parseNormalIndex(nc, nLen);\n        this.addNormal(ia, ib, ic);\n      } else {\n        this.addFaceNormal(ia, ib, ic);\n      }\n      if (ua !== void 0 && ua !== \"\") {\n        const uvLen = this.uvs.length;\n        ia = this.parseUVIndex(ua, uvLen);\n        ib = this.parseUVIndex(ub, uvLen);\n        ic = this.parseUVIndex(uc, uvLen);\n        this.addUV(ia, ib, ic);\n        this.object.geometry.hasUVIndices = true;\n      } else {\n        this.addDefaultUV();\n      }\n    },\n    addPointGeometry: function(vertices) {\n      this.object.geometry.type = \"Points\";\n      const vLen = this.vertices.length;\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen);\n        this.addVertexPoint(index);\n        this.addColor(index);\n      }\n    },\n    addLineGeometry: function(vertices, uvs) {\n      this.object.geometry.type = \"Line\";\n      const vLen = this.vertices.length;\n      const uvLen = this.uvs.length;\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n      }\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n      }\n    }\n  };\n  state.startObject(\"\", false);\n  return state;\n}\nclass OBJLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = null;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      },\n      onProgress,\n      onError\n    );\n  }\n  setMaterials(materials) {\n    this.materials = materials;\n    return this;\n  }\n  parse(text) {\n    const state = new ParserState();\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    if (text.indexOf(\"\\\\\\n\") !== -1) {\n      text = text.replace(/\\\\\\n/g, \"\");\n    }\n    const lines = text.split(\"\\n\");\n    let line = \"\", lineFirstChar = \"\";\n    let lineLength = 0;\n    let result = [];\n    const trimLeft = typeof \"\".trimLeft === \"function\";\n    for (let i = 0, l = lines.length; i < l; i++) {\n      line = lines[i];\n      line = trimLeft ? line.trimLeft() : line.trim();\n      lineLength = line.length;\n      if (lineLength === 0)\n        continue;\n      lineFirstChar = line.charAt(0);\n      if (lineFirstChar === \"#\")\n        continue;\n      if (lineFirstChar === \"v\") {\n        const data = line.split(/\\s+/);\n        switch (data[0]) {\n          case \"v\":\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n            if (data.length >= 7) {\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n            } else {\n              state.colors.push(void 0, void 0, void 0);\n            }\n            break;\n          case \"vn\":\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n            break;\n          case \"vt\":\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n            break;\n        }\n      } else if (lineFirstChar === \"f\") {\n        const lineData = line.substr(1).trim();\n        const vertexData = lineData.split(/\\s+/);\n        const faceVertices = [];\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex = vertexData[j];\n          if (vertex.length > 0) {\n            const vertexParts = vertex.split(\"/\");\n            faceVertices.push(vertexParts);\n          }\n        }\n        const v1 = faceVertices[0];\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j];\n          const v3 = faceVertices[j + 1];\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n        }\n      } else if (lineFirstChar === \"l\") {\n        const lineParts = line.substring(1).trim().split(\" \");\n        let lineVertices = [];\n        const lineUVs = [];\n        if (line.indexOf(\"/\") === -1) {\n          lineVertices = lineParts;\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split(\"/\");\n            if (parts[0] !== \"\")\n              lineVertices.push(parts[0]);\n            if (parts[1] !== \"\")\n              lineUVs.push(parts[1]);\n          }\n        }\n        state.addLineGeometry(lineVertices, lineUVs);\n      } else if (lineFirstChar === \"p\") {\n        const lineData = line.substr(1).trim();\n        const pointData = lineData.split(\" \");\n        state.addPointGeometry(pointData);\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        const name = (\" \" + result[0].substr(1).trim()).substr(1);\n        state.startObject(name);\n      } else if (_material_use_pattern.test(line)) {\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n      } else if (_material_library_pattern.test(line)) {\n        state.materialLibraries.push(line.substring(7).trim());\n      } else if (_map_use_pattern.test(line)) {\n        console.warn(\n          'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.'\n        );\n      } else if (lineFirstChar === \"s\") {\n        result = line.split(\" \");\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase();\n          state.object.smooth = value !== \"0\" && value !== \"off\";\n        } else {\n          state.object.smooth = true;\n        }\n        const material = state.object.currentMaterial();\n        if (material)\n          material.smooth = state.object.smooth;\n      } else {\n        if (line === \"\\0\")\n          continue;\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n      }\n    }\n    state.finalize();\n    const container = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    container.materialLibraries = [].concat(state.materialLibraries);\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i];\n        const geometry = object.geometry;\n        const materials = object.materials;\n        const isLine = geometry.type === \"Line\";\n        const isPoints = geometry.type === \"Points\";\n        let hasVertexColors = false;\n        if (geometry.vertices.length === 0)\n          continue;\n        const buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        buffergeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.vertices, 3));\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute(\"normal\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.normals, 3));\n        }\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true;\n          buffergeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.colors, 3));\n        }\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.uvs, 2));\n        }\n        const createdMaterials = [];\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi];\n          const materialHash = sourceMaterial.name + \"_\" + sourceMaterial.smooth + \"_\" + hasVertexColors;\n          let material = state.materials[materialHash];\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name);\n            if (isLine && material && !(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial)) {\n              const materialLine = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n              three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(materialLine, material);\n              materialLine.color.copy(material.color);\n              material = materialLine;\n            } else if (isPoints && material && !(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial)) {\n              const materialPoints = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({ size: 10, sizeAttenuation: false });\n              three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(materialPoints, material);\n              materialPoints.color.copy(material.color);\n              materialPoints.map = material.map;\n              material = materialPoints;\n            }\n          }\n          if (material === void 0) {\n            if (isLine) {\n              material = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n            } else if (isPoints) {\n              material = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({ size: 1, sizeAttenuation: false });\n            } else {\n              material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n            }\n            material.name = sourceMaterial.name;\n            material.flatShading = sourceMaterial.smooth ? false : true;\n            material.vertexColors = hasVertexColors;\n            state.materials[materialHash] = material;\n          }\n          createdMaterials.push(material);\n        }\n        let mesh;\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi];\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n          }\n          if (isLine) {\n            mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(buffergeometry, createdMaterials);\n          } else if (isPoints) {\n            mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(buffergeometry, createdMaterials);\n          } else {\n            mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(buffergeometry, createdMaterials);\n          }\n        } else {\n          if (isLine) {\n            mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(buffergeometry, createdMaterials[0]);\n          } else if (isPoints) {\n            mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(buffergeometry, createdMaterials[0]);\n          } else {\n            mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(buffergeometry, createdMaterials[0]);\n          }\n        }\n        mesh.name = object.name;\n        container.add(mesh);\n      }\n    } else {\n      if (state.vertices.length > 0) {\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({ size: 1, sizeAttenuation: false });\n        const buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        buffergeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(state.vertices, 3));\n        if (state.colors.length > 0 && state.colors[0] !== void 0) {\n          buffergeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(state.colors, 3));\n          material.vertexColors = true;\n        }\n        const points = new three__WEBPACK_IMPORTED_MODULE_0__.Points(buffergeometry, material);\n        container.add(points);\n      }\n    }\n    return container;\n  }\n}\n\n//# sourceMappingURL=OBJLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvT0JKTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStMO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUFPO0FBQ3ZCLGdCQUFnQiwwQ0FBTztBQUN2QixnQkFBZ0IsMENBQU87QUFDdkIsZ0JBQWdCLDBDQUFPO0FBQ3ZCLGdCQUFnQiwwQ0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlEQUFjO0FBQ2pELG9EQUFvRCx5REFBc0I7QUFDMUU7QUFDQSxvREFBb0QseURBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5REFBc0I7QUFDekU7QUFDQTtBQUNBLGdEQUFnRCx5REFBc0I7QUFDdEU7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0RBQWlCO0FBQzdFLHVDQUF1QyxvREFBaUI7QUFDeEQsY0FBYywyQ0FBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyx1REFBdUQsaURBQWM7QUFDbkYseUNBQXlDLGlEQUFjLEdBQUcsa0NBQWtDO0FBQzVGLGNBQWMsMkNBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQWlCO0FBQzlDLGNBQWM7QUFDZCw2QkFBNkIsaURBQWMsR0FBRyxpQ0FBaUM7QUFDL0UsY0FBYztBQUNkLDZCQUE2QixvREFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBWTtBQUNuQyxZQUFZO0FBQ1osdUJBQXVCLHlDQUFNO0FBQzdCLFlBQVk7QUFDWix1QkFBdUIsdUNBQUk7QUFDM0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1QkFBdUIsK0NBQVk7QUFDbkMsWUFBWTtBQUNaLHVCQUF1Qix5Q0FBTTtBQUM3QixZQUFZO0FBQ1osdUJBQXVCLHVDQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkIsaURBQWMsR0FBRyxpQ0FBaUM7QUFDL0UsbUNBQW1DLGlEQUFjO0FBQ2pELG9EQUFvRCx5REFBc0I7QUFDMUU7QUFDQSxtREFBbUQseURBQXNCO0FBQ3pFO0FBQ0E7QUFDQSwyQkFBMkIseUNBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21ldGEzNjAvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvT0JKTG9hZGVyLmpzPzUxMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMywgTG9hZGVyLCBGaWxlTG9hZGVyLCBHcm91cCwgQnVmZmVyR2VvbWV0cnksIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIExpbmVCYXNpY01hdGVyaWFsLCBNYXRlcmlhbCwgUG9pbnRzTWF0ZXJpYWwsIE1lc2hQaG9uZ01hdGVyaWFsLCBMaW5lU2VnbWVudHMsIFBvaW50cywgTWVzaCB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgX29iamVjdF9wYXR0ZXJuID0gL15bb2ddXFxzKiguKyk/LztcbmNvbnN0IF9tYXRlcmlhbF9saWJyYXJ5X3BhdHRlcm4gPSAvXm10bGxpYiAvO1xuY29uc3QgX21hdGVyaWFsX3VzZV9wYXR0ZXJuID0gL151c2VtdGwgLztcbmNvbnN0IF9tYXBfdXNlX3BhdHRlcm4gPSAvXnVzZW1hcCAvO1xuY29uc3QgX3ZBID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92QiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2FiID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9jYiA9IG5ldyBWZWN0b3IzKCk7XG5mdW5jdGlvbiBQYXJzZXJTdGF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgb2JqZWN0czogW10sXG4gICAgb2JqZWN0OiB7fSxcbiAgICB2ZXJ0aWNlczogW10sXG4gICAgbm9ybWFsczogW10sXG4gICAgY29sb3JzOiBbXSxcbiAgICB1dnM6IFtdLFxuICAgIG1hdGVyaWFsczoge30sXG4gICAgbWF0ZXJpYWxMaWJyYXJpZXM6IFtdLFxuICAgIHN0YXJ0T2JqZWN0OiBmdW5jdGlvbihuYW1lLCBmcm9tRGVjbGFyYXRpb24pIHtcbiAgICAgIGlmICh0aGlzLm9iamVjdCAmJiB0aGlzLm9iamVjdC5mcm9tRGVjbGFyYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub2JqZWN0Lm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm9iamVjdC5mcm9tRGVjbGFyYXRpb24gPSBmcm9tRGVjbGFyYXRpb24gIT09IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c01hdGVyaWFsID0gdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vYmplY3QuY3VycmVudE1hdGVyaWFsKCkgOiB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JqZWN0ID0ge1xuICAgICAgICBuYW1lOiBuYW1lIHx8IFwiXCIsXG4gICAgICAgIGZyb21EZWNsYXJhdGlvbjogZnJvbURlY2xhcmF0aW9uICE9PSBmYWxzZSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB2ZXJ0aWNlczogW10sXG4gICAgICAgICAgbm9ybWFsczogW10sXG4gICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICB1dnM6IFtdLFxuICAgICAgICAgIGhhc1VWSW5kaWNlczogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgbWF0ZXJpYWxzOiBbXSxcbiAgICAgICAgc21vb3RoOiB0cnVlLFxuICAgICAgICBzdGFydE1hdGVyaWFsOiBmdW5jdGlvbihuYW1lMiwgbGlicmFyaWVzKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9maW5hbGl6ZShmYWxzZSk7XG4gICAgICAgICAgaWYgKHByZXZpb3VzICYmIChwcmV2aW91cy5pbmhlcml0ZWQgfHwgcHJldmlvdXMuZ3JvdXBDb3VudCA8PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbHMuc3BsaWNlKHByZXZpb3VzLmluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB7XG4gICAgICAgICAgICBpbmRleDogdGhpcy5tYXRlcmlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgbmFtZTogbmFtZTIgfHwgXCJcIixcbiAgICAgICAgICAgIG10bGxpYjogQXJyYXkuaXNBcnJheShsaWJyYXJpZXMpICYmIGxpYnJhcmllcy5sZW5ndGggPiAwID8gbGlicmFyaWVzW2xpYnJhcmllcy5sZW5ndGggLSAxXSA6IFwiXCIsXG4gICAgICAgICAgICBzbW9vdGg6IHByZXZpb3VzICE9PSB2b2lkIDAgPyBwcmV2aW91cy5zbW9vdGggOiB0aGlzLnNtb290aCxcbiAgICAgICAgICAgIGdyb3VwU3RhcnQ6IHByZXZpb3VzICE9PSB2b2lkIDAgPyBwcmV2aW91cy5ncm91cEVuZCA6IDAsXG4gICAgICAgICAgICBncm91cEVuZDogLTEsXG4gICAgICAgICAgICBncm91cENvdW50OiAtMSxcbiAgICAgICAgICAgIGluaGVyaXRlZDogZmFsc2UsXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiB0eXBlb2YgaW5kZXggPT09IFwibnVtYmVyXCIgPyBpbmRleCA6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIG10bGxpYjogdGhpcy5tdGxsaWIsXG4gICAgICAgICAgICAgICAgc21vb3RoOiB0aGlzLnNtb290aCxcbiAgICAgICAgICAgICAgICBncm91cFN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIGdyb3VwRW5kOiAtMSxcbiAgICAgICAgICAgICAgICBncm91cENvdW50OiAtMSxcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNsb25lZC5jbG9uZSA9IHRoaXMuY2xvbmUuYmluZChjbG9uZWQpO1xuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5tYXRlcmlhbHMucHVzaChtYXRlcmlhbCk7XG4gICAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50TWF0ZXJpYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLm1hdGVyaWFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRlcmlhbHNbdGhpcy5tYXRlcmlhbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH0sXG4gICAgICAgIF9maW5hbGl6ZTogZnVuY3Rpb24oZW5kKSB7XG4gICAgICAgICAgY29uc3QgbGFzdE11bHRpTWF0ZXJpYWwgPSB0aGlzLmN1cnJlbnRNYXRlcmlhbCgpO1xuICAgICAgICAgIGlmIChsYXN0TXVsdGlNYXRlcmlhbCAmJiBsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwRW5kID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgICAgICAgICAgbGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBDb3VudCA9IGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwRW5kIC0gbGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBTdGFydDtcbiAgICAgICAgICAgIGxhc3RNdWx0aU1hdGVyaWFsLmluaGVyaXRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kICYmIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG1pID0gdGhpcy5tYXRlcmlhbHMubGVuZ3RoIC0gMTsgbWkgPj0gMDsgbWktLSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5tYXRlcmlhbHNbbWldLmdyb3VwQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxzLnNwbGljZShtaSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZCAmJiB0aGlzLm1hdGVyaWFscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICBzbW9vdGg6IHRoaXMuc21vb3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxhc3RNdWx0aU1hdGVyaWFsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHByZXZpb3VzTWF0ZXJpYWwgJiYgcHJldmlvdXNNYXRlcmlhbC5uYW1lICYmIHR5cGVvZiBwcmV2aW91c01hdGVyaWFsLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgZGVjbGFyZWQgPSBwcmV2aW91c01hdGVyaWFsLmNsb25lKDApO1xuICAgICAgICBkZWNsYXJlZC5pbmhlcml0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9iamVjdC5tYXRlcmlhbHMucHVzaChkZWNsYXJlZCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9iamVjdHMucHVzaCh0aGlzLm9iamVjdCk7XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlVmVydGV4SW5kZXg6IGZ1bmN0aW9uKHZhbHVlLCBsZW4pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgIHJldHVybiAoaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbGVuIC8gMykgKiAzO1xuICAgIH0sXG4gICAgcGFyc2VOb3JtYWxJbmRleDogZnVuY3Rpb24odmFsdWUsIGxlbikge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgcmV0dXJuIChpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyBsZW4gLyAzKSAqIDM7XG4gICAgfSxcbiAgICBwYXJzZVVWSW5kZXg6IGZ1bmN0aW9uKHZhbHVlLCBsZW4pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgIHJldHVybiAoaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbGVuIC8gMikgKiAyO1xuICAgIH0sXG4gICAgYWRkVmVydGV4OiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICBjb25zdCBzcmMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgY29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG4gICAgICBkc3QucHVzaChzcmNbYSArIDBdLCBzcmNbYSArIDFdLCBzcmNbYSArIDJdKTtcbiAgICAgIGRzdC5wdXNoKHNyY1tiICsgMF0sIHNyY1tiICsgMV0sIHNyY1tiICsgMl0pO1xuICAgICAgZHN0LnB1c2goc3JjW2MgKyAwXSwgc3JjW2MgKyAxXSwgc3JjW2MgKyAyXSk7XG4gICAgfSxcbiAgICBhZGRWZXJ0ZXhQb2ludDogZnVuY3Rpb24oYSkge1xuICAgICAgY29uc3Qgc3JjID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgIGNvbnN0IGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xuICAgICAgZHN0LnB1c2goc3JjW2EgKyAwXSwgc3JjW2EgKyAxXSwgc3JjW2EgKyAyXSk7XG4gICAgfSxcbiAgICBhZGRWZXJ0ZXhMaW5lOiBmdW5jdGlvbihhKSB7XG4gICAgICBjb25zdCBzcmMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgY29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG4gICAgICBkc3QucHVzaChzcmNbYSArIDBdLCBzcmNbYSArIDFdLCBzcmNbYSArIDJdKTtcbiAgICB9LFxuICAgIGFkZE5vcm1hbDogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgY29uc3Qgc3JjID0gdGhpcy5ub3JtYWxzO1xuICAgICAgY29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkubm9ybWFscztcbiAgICAgIGRzdC5wdXNoKHNyY1thICsgMF0sIHNyY1thICsgMV0sIHNyY1thICsgMl0pO1xuICAgICAgZHN0LnB1c2goc3JjW2IgKyAwXSwgc3JjW2IgKyAxXSwgc3JjW2IgKyAyXSk7XG4gICAgICBkc3QucHVzaChzcmNbYyArIDBdLCBzcmNbYyArIDFdLCBzcmNbYyArIDJdKTtcbiAgICB9LFxuICAgIGFkZEZhY2VOb3JtYWw6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIGNvbnN0IHNyYyA9IHRoaXMudmVydGljZXM7XG4gICAgICBjb25zdCBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5ub3JtYWxzO1xuICAgICAgX3ZBLmZyb21BcnJheShzcmMsIGEpO1xuICAgICAgX3ZCLmZyb21BcnJheShzcmMsIGIpO1xuICAgICAgX3ZDLmZyb21BcnJheShzcmMsIGMpO1xuICAgICAgX2NiLnN1YlZlY3RvcnMoX3ZDLCBfdkIpO1xuICAgICAgX2FiLnN1YlZlY3RvcnMoX3ZBLCBfdkIpO1xuICAgICAgX2NiLmNyb3NzKF9hYik7XG4gICAgICBfY2Iubm9ybWFsaXplKCk7XG4gICAgICBkc3QucHVzaChfY2IueCwgX2NiLnksIF9jYi56KTtcbiAgICAgIGRzdC5wdXNoKF9jYi54LCBfY2IueSwgX2NiLnopO1xuICAgICAgZHN0LnB1c2goX2NiLngsIF9jYi55LCBfY2Iueik7XG4gICAgfSxcbiAgICBhZGRDb2xvcjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgY29uc3Qgc3JjID0gdGhpcy5jb2xvcnM7XG4gICAgICBjb25zdCBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5jb2xvcnM7XG4gICAgICBpZiAoc3JjW2FdICE9PSB2b2lkIDApXG4gICAgICAgIGRzdC5wdXNoKHNyY1thICsgMF0sIHNyY1thICsgMV0sIHNyY1thICsgMl0pO1xuICAgICAgaWYgKHNyY1tiXSAhPT0gdm9pZCAwKVxuICAgICAgICBkc3QucHVzaChzcmNbYiArIDBdLCBzcmNbYiArIDFdLCBzcmNbYiArIDJdKTtcbiAgICAgIGlmIChzcmNbY10gIT09IHZvaWQgMClcbiAgICAgICAgZHN0LnB1c2goc3JjW2MgKyAwXSwgc3JjW2MgKyAxXSwgc3JjW2MgKyAyXSk7XG4gICAgfSxcbiAgICBhZGRVVjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgY29uc3Qgc3JjID0gdGhpcy51dnM7XG4gICAgICBjb25zdCBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS51dnM7XG4gICAgICBkc3QucHVzaChzcmNbYSArIDBdLCBzcmNbYSArIDFdKTtcbiAgICAgIGRzdC5wdXNoKHNyY1tiICsgMF0sIHNyY1tiICsgMV0pO1xuICAgICAgZHN0LnB1c2goc3JjW2MgKyAwXSwgc3JjW2MgKyAxXSk7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0VVY6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudXZzO1xuICAgICAgZHN0LnB1c2goMCwgMCk7XG4gICAgICBkc3QucHVzaCgwLCAwKTtcbiAgICAgIGRzdC5wdXNoKDAsIDApO1xuICAgIH0sXG4gICAgYWRkVVZMaW5lOiBmdW5jdGlvbihhKSB7XG4gICAgICBjb25zdCBzcmMgPSB0aGlzLnV2cztcbiAgICAgIGNvbnN0IGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnV2cztcbiAgICAgIGRzdC5wdXNoKHNyY1thICsgMF0sIHNyY1thICsgMV0pO1xuICAgIH0sXG4gICAgYWRkRmFjZTogZnVuY3Rpb24oYSwgYiwgYywgdWEsIHViLCB1YywgbmEsIG5iLCBuYykge1xuICAgICAgY29uc3QgdkxlbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgbGV0IGlhID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KGEsIHZMZW4pO1xuICAgICAgbGV0IGliID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KGIsIHZMZW4pO1xuICAgICAgbGV0IGljID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KGMsIHZMZW4pO1xuICAgICAgdGhpcy5hZGRWZXJ0ZXgoaWEsIGliLCBpYyk7XG4gICAgICB0aGlzLmFkZENvbG9yKGlhLCBpYiwgaWMpO1xuICAgICAgaWYgKG5hICE9PSB2b2lkIDAgJiYgbmEgIT09IFwiXCIpIHtcbiAgICAgICAgY29uc3QgbkxlbiA9IHRoaXMubm9ybWFscy5sZW5ndGg7XG4gICAgICAgIGlhID0gdGhpcy5wYXJzZU5vcm1hbEluZGV4KG5hLCBuTGVuKTtcbiAgICAgICAgaWIgPSB0aGlzLnBhcnNlTm9ybWFsSW5kZXgobmIsIG5MZW4pO1xuICAgICAgICBpYyA9IHRoaXMucGFyc2VOb3JtYWxJbmRleChuYywgbkxlbik7XG4gICAgICAgIHRoaXMuYWRkTm9ybWFsKGlhLCBpYiwgaWMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRGYWNlTm9ybWFsKGlhLCBpYiwgaWMpO1xuICAgICAgfVxuICAgICAgaWYgKHVhICE9PSB2b2lkIDAgJiYgdWEgIT09IFwiXCIpIHtcbiAgICAgICAgY29uc3QgdXZMZW4gPSB0aGlzLnV2cy5sZW5ndGg7XG4gICAgICAgIGlhID0gdGhpcy5wYXJzZVVWSW5kZXgodWEsIHV2TGVuKTtcbiAgICAgICAgaWIgPSB0aGlzLnBhcnNlVVZJbmRleCh1YiwgdXZMZW4pO1xuICAgICAgICBpYyA9IHRoaXMucGFyc2VVVkluZGV4KHVjLCB1dkxlbik7XG4gICAgICAgIHRoaXMuYWRkVVYoaWEsIGliLCBpYyk7XG4gICAgICAgIHRoaXMub2JqZWN0Lmdlb21ldHJ5Lmhhc1VWSW5kaWNlcyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZERlZmF1bHRVVigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkUG9pbnRHZW9tZXRyeTogZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgIHRoaXMub2JqZWN0Lmdlb21ldHJ5LnR5cGUgPSBcIlBvaW50c1wiO1xuICAgICAgY29uc3QgdkxlbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgdmkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyB2aSA8IGw7IHZpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBhcnNlVmVydGV4SW5kZXgodmVydGljZXNbdmldLCB2TGVuKTtcbiAgICAgICAgdGhpcy5hZGRWZXJ0ZXhQb2ludChpbmRleCk7XG4gICAgICAgIHRoaXMuYWRkQ29sb3IoaW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTGluZUdlb21ldHJ5OiBmdW5jdGlvbih2ZXJ0aWNlcywgdXZzKSB7XG4gICAgICB0aGlzLm9iamVjdC5nZW9tZXRyeS50eXBlID0gXCJMaW5lXCI7XG4gICAgICBjb25zdCB2TGVuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICBjb25zdCB1dkxlbiA9IHRoaXMudXZzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IHZpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgdmkgPCBsOyB2aSsrKSB7XG4gICAgICAgIHRoaXMuYWRkVmVydGV4TGluZSh0aGlzLnBhcnNlVmVydGV4SW5kZXgodmVydGljZXNbdmldLCB2TGVuKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB1dmkgPSAwLCBsID0gdXZzLmxlbmd0aDsgdXZpIDwgbDsgdXZpKyspIHtcbiAgICAgICAgdGhpcy5hZGRVVkxpbmUodGhpcy5wYXJzZVVWSW5kZXgodXZzW3V2aV0sIHV2TGVuKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGF0ZS5zdGFydE9iamVjdChcIlwiLCBmYWxzZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNsYXNzIE9CSkxvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLm1hdGVyaWFscyA9IG51bGw7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbkxvYWQoc2NvcGUucGFyc2UodGV4dCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25FcnJvclxuICAgICk7XG4gIH1cbiAgc2V0TWF0ZXJpYWxzKG1hdGVyaWFscykge1xuICAgIHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBhcnNlKHRleHQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBQYXJzZXJTdGF0ZSgpO1xuICAgIGlmICh0ZXh0LmluZGV4T2YoXCJcXHJcXG5cIikgIT09IC0xKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIik7XG4gICAgfVxuICAgIGlmICh0ZXh0LmluZGV4T2YoXCJcXFxcXFxuXCIpICE9PSAtMSkge1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxcXFxcbi9nLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgIGxldCBsaW5lID0gXCJcIiwgbGluZUZpcnN0Q2hhciA9IFwiXCI7XG4gICAgbGV0IGxpbmVMZW5ndGggPSAwO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB0cmltTGVmdCA9IHR5cGVvZiBcIlwiLnRyaW1MZWZ0ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIGxpbmUgPSB0cmltTGVmdCA/IGxpbmUudHJpbUxlZnQoKSA6IGxpbmUudHJpbSgpO1xuICAgICAgbGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgaWYgKGxpbmVMZW5ndGggPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGluZUZpcnN0Q2hhciA9IGxpbmUuY2hhckF0KDApO1xuICAgICAgaWYgKGxpbmVGaXJzdENoYXIgPT09IFwiI1wiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChsaW5lRmlyc3RDaGFyID09PSBcInZcIikge1xuICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBzd2l0Y2ggKGRhdGFbMF0pIHtcbiAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgc3RhdGUudmVydGljZXMucHVzaChwYXJzZUZsb2F0KGRhdGFbMV0pLCBwYXJzZUZsb2F0KGRhdGFbMl0pLCBwYXJzZUZsb2F0KGRhdGFbM10pKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSA3KSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNvbG9ycy5wdXNoKHBhcnNlRmxvYXQoZGF0YVs0XSksIHBhcnNlRmxvYXQoZGF0YVs1XSksIHBhcnNlRmxvYXQoZGF0YVs2XSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUuY29sb3JzLnB1c2godm9pZCAwLCB2b2lkIDAsIHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidm5cIjpcbiAgICAgICAgICAgIHN0YXRlLm5vcm1hbHMucHVzaChwYXJzZUZsb2F0KGRhdGFbMV0pLCBwYXJzZUZsb2F0KGRhdGFbMl0pLCBwYXJzZUZsb2F0KGRhdGFbM10pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ2dFwiOlxuICAgICAgICAgICAgc3RhdGUudXZzLnB1c2gocGFyc2VGbG9hdChkYXRhWzFdKSwgcGFyc2VGbG9hdChkYXRhWzJdKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsaW5lRmlyc3RDaGFyID09PSBcImZcIikge1xuICAgICAgICBjb25zdCBsaW5lRGF0YSA9IGxpbmUuc3Vic3RyKDEpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgdmVydGV4RGF0YSA9IGxpbmVEYXRhLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGNvbnN0IGZhY2VWZXJ0aWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB2ZXJ0ZXhEYXRhW2pdO1xuICAgICAgICAgIGlmICh2ZXJ0ZXgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdmVydGV4UGFydHMgPSB2ZXJ0ZXguc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2godmVydGV4UGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2MSA9IGZhY2VWZXJ0aWNlc1swXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDEsIGpsID0gZmFjZVZlcnRpY2VzLmxlbmd0aCAtIDE7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgdjIgPSBmYWNlVmVydGljZXNbal07XG4gICAgICAgICAgY29uc3QgdjMgPSBmYWNlVmVydGljZXNbaiArIDFdO1xuICAgICAgICAgIHN0YXRlLmFkZEZhY2UodjFbMF0sIHYyWzBdLCB2M1swXSwgdjFbMV0sIHYyWzFdLCB2M1sxXSwgdjFbMl0sIHYyWzJdLCB2M1syXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGluZUZpcnN0Q2hhciA9PT0gXCJsXCIpIHtcbiAgICAgICAgY29uc3QgbGluZVBhcnRzID0gbGluZS5zdWJzdHJpbmcoMSkudHJpbSgpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgbGV0IGxpbmVWZXJ0aWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBsaW5lVVZzID0gW107XG4gICAgICAgIGlmIChsaW5lLmluZGV4T2YoXCIvXCIpID09PSAtMSkge1xuICAgICAgICAgIGxpbmVWZXJ0aWNlcyA9IGxpbmVQYXJ0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBsaSA9IDAsIGxsZW4gPSBsaW5lUGFydHMubGVuZ3RoOyBsaSA8IGxsZW47IGxpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZVBhcnRzW2xpXS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICBpZiAocGFydHNbMF0gIT09IFwiXCIpXG4gICAgICAgICAgICAgIGxpbmVWZXJ0aWNlcy5wdXNoKHBhcnRzWzBdKTtcbiAgICAgICAgICAgIGlmIChwYXJ0c1sxXSAhPT0gXCJcIilcbiAgICAgICAgICAgICAgbGluZVVWcy5wdXNoKHBhcnRzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWRkTGluZUdlb21ldHJ5KGxpbmVWZXJ0aWNlcywgbGluZVVWcyk7XG4gICAgICB9IGVsc2UgaWYgKGxpbmVGaXJzdENoYXIgPT09IFwicFwiKSB7XG4gICAgICAgIGNvbnN0IGxpbmVEYXRhID0gbGluZS5zdWJzdHIoMSkudHJpbSgpO1xuICAgICAgICBjb25zdCBwb2ludERhdGEgPSBsaW5lRGF0YS5zcGxpdChcIiBcIik7XG4gICAgICAgIHN0YXRlLmFkZFBvaW50R2VvbWV0cnkocG9pbnREYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IF9vYmplY3RfcGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBuYW1lID0gKFwiIFwiICsgcmVzdWx0WzBdLnN1YnN0cigxKS50cmltKCkpLnN1YnN0cigxKTtcbiAgICAgICAgc3RhdGUuc3RhcnRPYmplY3QobmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKF9tYXRlcmlhbF91c2VfcGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgIHN0YXRlLm9iamVjdC5zdGFydE1hdGVyaWFsKGxpbmUuc3Vic3RyaW5nKDcpLnRyaW0oKSwgc3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMpO1xuICAgICAgfSBlbHNlIGlmIChfbWF0ZXJpYWxfbGlicmFyeV9wYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgc3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMucHVzaChsaW5lLnN1YnN0cmluZyg3KS50cmltKCkpO1xuICAgICAgfSBlbHNlIGlmIChfbWFwX3VzZV9wYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUSFJFRS5PQkpMb2FkZXI6IFJlbmRlcmluZyBpZGVudGlmaWVyIFwidXNlbWFwXCIgbm90IHN1cHBvcnRlZC4gVGV4dHVyZXMgbXVzdCBiZSBkZWZpbmVkIGluIE1UTCBmaWxlcy4nXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGxpbmVGaXJzdENoYXIgPT09IFwic1wiKSB7XG4gICAgICAgIHJlc3VsdCA9IGxpbmUuc3BsaXQoXCIgXCIpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFsxXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBzdGF0ZS5vYmplY3Quc21vb3RoID0gdmFsdWUgIT09IFwiMFwiICYmIHZhbHVlICE9PSBcIm9mZlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLm9iamVjdC5zbW9vdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gc3RhdGUub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCgpO1xuICAgICAgICBpZiAobWF0ZXJpYWwpXG4gICAgICAgICAgbWF0ZXJpYWwuc21vb3RoID0gc3RhdGUub2JqZWN0LnNtb290aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW5lID09PSBcIlxcMFwiKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLk9CSkxvYWRlcjogVW5leHBlY3RlZCBsaW5lOiBcIicgKyBsaW5lICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmZpbmFsaXplKCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IEdyb3VwKCk7XG4gICAgY29udGFpbmVyLm1hdGVyaWFsTGlicmFyaWVzID0gW10uY29uY2F0KHN0YXRlLm1hdGVyaWFsTGlicmFyaWVzKTtcbiAgICBjb25zdCBoYXNQcmltaXRpdmVzID0gIShzdGF0ZS5vYmplY3RzLmxlbmd0aCA9PT0gMSAmJiBzdGF0ZS5vYmplY3RzWzBdLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA9PT0gMCk7XG4gICAgaWYgKGhhc1ByaW1pdGl2ZXMgPT09IHRydWUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3RhdGUub2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gc3RhdGUub2JqZWN0c1tpXTtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFscyA9IG9iamVjdC5tYXRlcmlhbHM7XG4gICAgICAgIGNvbnN0IGlzTGluZSA9IGdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVwiO1xuICAgICAgICBjb25zdCBpc1BvaW50cyA9IGdlb21ldHJ5LnR5cGUgPT09IFwiUG9pbnRzXCI7XG4gICAgICAgIGxldCBoYXNWZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYnVmZmVyZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgYnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnkudmVydGljZXMsIDMpKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeS5ub3JtYWxzLCAzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaGFzVmVydGV4Q29sb3JzID0gdHJ1ZTtcbiAgICAgICAgICBidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJjb2xvclwiLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeS5jb2xvcnMsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VvbWV0cnkuaGFzVVZJbmRpY2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgYnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwidXZcIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnkudXZzLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZE1hdGVyaWFscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBtaSA9IDAsIG1pTGVuID0gbWF0ZXJpYWxzLmxlbmd0aDsgbWkgPCBtaUxlbjsgbWkrKykge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZU1hdGVyaWFsID0gbWF0ZXJpYWxzW21pXTtcbiAgICAgICAgICBjb25zdCBtYXRlcmlhbEhhc2ggPSBzb3VyY2VNYXRlcmlhbC5uYW1lICsgXCJfXCIgKyBzb3VyY2VNYXRlcmlhbC5zbW9vdGggKyBcIl9cIiArIGhhc1ZlcnRleENvbG9ycztcbiAgICAgICAgICBsZXQgbWF0ZXJpYWwgPSBzdGF0ZS5tYXRlcmlhbHNbbWF0ZXJpYWxIYXNoXTtcbiAgICAgICAgICBpZiAodGhpcy5tYXRlcmlhbHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbHMuY3JlYXRlKHNvdXJjZU1hdGVyaWFsLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGlzTGluZSAmJiBtYXRlcmlhbCAmJiAhKG1hdGVyaWFsIGluc3RhbmNlb2YgTGluZUJhc2ljTWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsTGluZSA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKG1hdGVyaWFsTGluZSwgbWF0ZXJpYWwpO1xuICAgICAgICAgICAgICBtYXRlcmlhbExpbmUuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgICAgICAgIG1hdGVyaWFsID0gbWF0ZXJpYWxMaW5lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BvaW50cyAmJiBtYXRlcmlhbCAmJiAhKG1hdGVyaWFsIGluc3RhbmNlb2YgUG9pbnRzTWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsUG9pbnRzID0gbmV3IFBvaW50c01hdGVyaWFsKHsgc2l6ZTogMTAsIHNpemVBdHRlbnVhdGlvbjogZmFsc2UgfSk7XG4gICAgICAgICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwobWF0ZXJpYWxQb2ludHMsIG1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgbWF0ZXJpYWxQb2ludHMuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgICAgICAgIG1hdGVyaWFsUG9pbnRzLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBtYXRlcmlhbFBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGVyaWFsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQb2ludHMpIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoeyBzaXplOiAxLCBzaXplQXR0ZW51YXRpb246IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGVyaWFsLm5hbWUgPSBzb3VyY2VNYXRlcmlhbC5uYW1lO1xuICAgICAgICAgICAgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBzb3VyY2VNYXRlcmlhbC5zbW9vdGggPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBoYXNWZXJ0ZXhDb2xvcnM7XG4gICAgICAgICAgICBzdGF0ZS5tYXRlcmlhbHNbbWF0ZXJpYWxIYXNoXSA9IG1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjcmVhdGVkTWF0ZXJpYWxzLnB1c2gobWF0ZXJpYWwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNoO1xuICAgICAgICBpZiAoY3JlYXRlZE1hdGVyaWFscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgZm9yIChsZXQgbWkgPSAwLCBtaUxlbiA9IG1hdGVyaWFscy5sZW5ndGg7IG1pIDwgbWlMZW47IG1pKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hdGVyaWFsID0gbWF0ZXJpYWxzW21pXTtcbiAgICAgICAgICAgIGJ1ZmZlcmdlb21ldHJ5LmFkZEdyb3VwKHNvdXJjZU1hdGVyaWFsLmdyb3VwU3RhcnQsIHNvdXJjZU1hdGVyaWFsLmdyb3VwQ291bnQsIG1pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgbWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQb2ludHMpIHtcbiAgICAgICAgICAgIG1lc2ggPSBuZXcgUG9pbnRzKGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzaCA9IG5ldyBNZXNoKGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgbWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHNbMF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQb2ludHMpIHtcbiAgICAgICAgICAgIG1lc2ggPSBuZXcgUG9pbnRzKGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzaCA9IG5ldyBNZXNoKGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVzaC5uYW1lID0gb2JqZWN0Lm5hbWU7XG4gICAgICAgIGNvbnRhaW5lci5hZGQobWVzaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS52ZXJ0aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKHsgc2l6ZTogMSwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgYnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoc3RhdGUudmVydGljZXMsIDMpKTtcbiAgICAgICAgaWYgKHN0YXRlLmNvbG9ycy5sZW5ndGggPiAwICYmIHN0YXRlLmNvbG9yc1swXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwiY29sb3JcIiwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoc3RhdGUuY29sb3JzLCAzKSk7XG4gICAgICAgICAgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHMgPSBuZXcgUG9pbnRzKGJ1ZmZlcmdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIGNvbnRhaW5lci5hZGQocG9pbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuZXhwb3J0IHtcbiAgT0JKTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T0JKTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/OBJLoader.js\n");

/***/ })

};
;